#!/bin/zsh
#
# Autor: Kai Wilke <kiste@netzworkk.de> 21.12.2011
#
# Script: kwssl2, erstellt eine PKI (Public Key Infrastructur),
# Certrifikate, signiert....
#
# Version: 0.0.1
#

# Ausführen von Befehlen auf bestimmte Signale.
# Notiz. Immer den Namen verwenden, da es auf einigen OS
# eine andere Numerierung geben kann.
#
trap 'setterm -inversescreen off ; setterm -reset ;
rm -rf $gv_WorkDir &>/dev/null' EXIT INT

gv_ScriptName=${0##*/}

# Verzeichniss in denen nach Funktionen gesucht wird
#
if [ -f /usr/local/share/kwtools/functions/sys/script_init ] ; then
	PREFIX=/usr/local
else
	PREFIX=/usr
fi
Script_init_Fpath="${PREFIX}/share/kwtools/functions/sys"
export TEXTDOMAINDIR="${PREFIX}/share/locale"
export TEXTDOMAIN="$gv_ScriptName"

if [ -z ${(M)${FPATH}##*${Script_init_Fpath}*} ] ; then
	FPATH=${Script_init_Fpath}:${FPATH}
fi

# script_init enthält die globalen Scripteinstellungen und lädt
# diese automatisch.
#
autoload -U script_init

# Scriptinitialisierung
script_init

# auf Programme pruefen
prog_check openssl
if [ -z "$PROGS" ] ; then
	exit 0
fi

# Variablen belegen# {{{
UNSET=(CA_NAME COMMONNAME COUNTRYCODE PASSWORD COUNTRY LOCATION
	ORGANISATION ORGANISATIONUNIT MAIL VALIDITY KEYLENGTH DIGEST gv_Pass
	FILENAME CA_CAPASSWD)
#
KWSSL_DIR="${gv_HomePath}/.kwtools/kwssl2"
KWSSL2RC_NAME=kwssl2rc
DISPLAY_FILE="${gv_WorkDir}/display"

# gettext
lv_CA=$(gettext 'CA')
lv_SubCa=$(gettext 'SubCA')
lv_CA_Create=$(gettext 'CA erstellen')
lv_SubCA_Create=$(gettext 'SubCA erstellen')
lv_Server_Ca=$(gettext 'Server Zertifikate')
lv_User_Ca=$(gettext 'Benutzer Zertifikate')
lv_CA_Import=$(gettext 'CA importieren')
lv_CA_Export=$(gettext 'CA exportieren')
lv_Export=$(gettext 'exportieren')
lv_CA_Password=$(gettext 'neues CA Passwort')
lv_CA_Revoke=$(gettext 'CA widerrufen')
lv_Dh_File=$(gettext 'Diffie Hellman')
lv_UserCA_Create=$(gettext 'Benutzer Zertifikat erstellen')
lv_ServerCA_Create=$(gettext 'Server Zertifikat erstellen')
lv_Cert=$(gettext 'Zertifikate')
lv_ExportFilename=$(gettext 'Export Dateiname')
lv_YesValidity=$(gettext 'gueltig')
lv_NoValidity=$(gettext 'ungueltig')
lv_RevokeValidity=$(gettext 'widerrufen')
lv_Open=$(gettext 'oeffnen')
#
lv_Ssl_Name=$(gettext 'Name')
lv_Ssl_ServerName=$(gettext 'Servername')
lv_Ssl_UserName=$(gettext 'Benutzername')
lv_Ssl_CommonName=$(gettext 'allgemeiner Name')
lv_Ssl_Land_Code=$(gettext 'Land')
lv_Ssl_CA_Password=$(gettext 'CA Passwort')
lv_Ssl_Password=$(gettext 'Passwort eingeben')
lv_Ssl_Password_Generate=$(gettext 'Passwort generieren')
lv_Ssl_Bundesstaat=$(gettext 'Bundesstaat')
lv_Ssl_Location=$(gettext 'Standort')
lv_Ssl_Organisation=$(gettext 'Organisation')
lv_Ssl_Organisation_Unit=$(gettext 'Organisationseinheit')
lv_Ssl_Email=$(gettext 'Mail')
lv_Ssl_Validity=$(gettext 'Gueltigkeit')
lv_Ssl_Key_length=$(gettext 'Schluessellaenge')
lv_Ssl_Digest=$(gettext 'Digest')
lv_Ssl_Alg=$(gettext 'Algotrithmus')
## }}}
# Variablen, Einstellungen# {{{
DEFAULT_CONF_TITLE="$gv_Configuration"
DEFAULT_URL_MSG=$(gettext 'URL Eingabe')
lv_Ca_Certs=$(gettext 'CA Zertifikate')
lv_Revokes=$(gettext 'Widerrufslisten')
lv_Revoke_Days=$(gettext 'Standardtage')
lv_Filename=$(gettext 'Dateiname')
#
lv_SubjectAlternateName=$(gettext 'Subject Alternative Name')
lv_NsCertType=$(gettext 'Netscape Zertifikatstyp')
lv_Ns_Ssl_ServerName=$(gettext 'Netscape SSL Servername')
lv_KeyUsage=$(gettext 'Schluesselverwendung')
lv_EKeyUsage=$(gettext 'erweiterte Schluesselverwendung')
lv_Critical_Ca=$(gettext 'kritisch oder nicht')
lv_NsRevocationUrl=$(gettext 'Netscape Widerrufs URL')
lv_NsRenewalUrl=$(gettext 'Netscape Erneuerungs URL')
lv_NsCaRevocationUrl=$(gettext 'Netscape CA Widerrufs URL')
lv_NsComment=$(gettext 'Netscape Kommentar')
lv_CrlDistributionPoints=$(gettext 'crlDistributionPoints')
lv_AuthKeyIdent=$(gettext 'authorityKeyIdentifier')
lv_IssuerAltName=$(gettext 'issuerAltName')
lv_NsBaseUrl=$(gettext 'nsBaseUrl')
lv_NsPolicyUrl=$(gettext 'nsPolicyUrl')
lv_NsCaPolicyUrl=$(gettext 'nsCaPolicyUrl')
lv_BasicConstraints=$(gettext 'basicConstraints')
#
lv_CopyMail=$(gettext 'Kopiere Email')
lv_Qestion_User=$(gettext 'Frage Benutzer')
lv_Critical=$(gettext 'kritisch')
lv_UnCritical=$(gettext 'unkritisch')
lv_SSL_Ca=$(gettext 'SSL CA')
lv_SSL_SERVER=$(gettext 'SSL Server')
lv_SSL_CLIENT=$(gettext 'SSL Client')
lv_SSL_USER=$(gettext 'SSL Benutzer')
lv_SSL_SERVER_CLIENT=$(gettext 'SSL Server, SSL Client')
lv_SMime_Ca=$(gettext 'S/MIME CA')
lv_ObjectSign_Ca=$(gettext 'Object Signierende CA')
lv_SMime_SSL_Ca=$(gettext 'SSL CA, S/MIME CA')
lv_ObjectSign_SSL_Ca=$(gettext 'SSL CA, Object Signierende CA')
lv_SMime_ObjectSign_Ca=$(gettext 'S/MIME, Object Signierende CA')
lv_SMime_SSL_ObjectSign_Ca=$(gettext 'SSL CA, S/MIME CA, Objekt Signierende CA')
lv_CertSign_Ca=$(gettext 'Zertifikate signieren')
lv_CrlSign_Ca=$(gettext 'CRL signieren')
lv_CertSign_CrlSign_Ca=$(gettext 'Zertifikate signieren, CRL signieren')
lv_DigitalSign=$(gettext 'Digitale Signatur')
lv_Encrypt=$(gettext 'Verschluesselung')
lv_Encrypt_DigitalSign=$(gettext 'Verschluesselung, Digitale Signatur')
lv_User_ObjectSign=$(gettext 'Object Signieren')
lv_User_Smime=$(gettext 'Email S/MIME')
lv_User_Usr_Smime=$(gettext 'SSL Benutzer, Email S/MIME')
lv_User_Usr_ObjectSign=$(gettext 'SSL Benutzer, Object Signieren')
lv_User_Usr_Email_ObjectSign=$(gettext 'SSL Benutzer, Email, Object Signieren')
lv_BasicConstraints=$(gettext 'basicConstraints')
#
SAVE_MSG=$(gettext 'Geben Sie den Namen fuer die lokale Speicherung ein.')
#
DEFAULT_REVOKE_DAYS=${DEFAULT_REVOKE_DAYS:-30}
VALIDITY=${VALIDITY:-3650}
SUBJECT_ALTER_NAME=${SUBJECT_ALTER_NAME:-$lv_CopyMail}
NSCERTTYPE=${NSCERTTYPE:-$lv_SMime_SSL_Ca}
KEYUSAGE=${KEYUSAGE:-$lv_CertSign_CrlSign_Ca}
NSCOMMENT=${NSCOMMENT:-"$gv_ScriptName Generated Certificate"}
#
DIGEST="${DIGEST:-SHA-1}"
CA_NAME=${CA_NAME:-$CA_OPEN_NAME}
# Standard Passphrasen Laenge ist 10 Zeichen lang
# wenn keine Passphrase manuell eingegeben wurde.
PASSWD_LENGTH="${PASSWD_LENGTH:-10}"
#
## }}}

# Nachdem das Script initialisiert wurde, kann man die anderen
# benötigten Funktionen laden. Die Funktion sys_conf wird bereits
# von der Funktion script_init ausgefuehrt.
autoload -U conf_ca kwssl_config net_conf ca_certs_conf
net_conf

# Funktion (create_pki), Verzeichnisstruktur erstellen# {{{
#
# usage: create_pki CA-NAME (DIRNAME)
#
create_pki() {
	if [[ ${#argv} == 1 ]] ; then
		unset -- DIR
		DIR="$1"
		if [ ! -d ${KWSSL_DIR}/${DIR} ] ; then
	        mkdir -p ${KWSSL_DIR}/${DIR}/{newcerts,certs,crl,keys,req} &>/dev/null
	        chmod 700 ${KWSSL_DIR}/${DIR}/{newcerts,certs,crl,keys,req} &>/dev/null
			cd $KWSSL_DIR
	        touch ./${DIR}/{index.txt,serial,crlnumber} &>/dev/null
	        echo "01" > ./${DIR}/{serial,crlnumber} &>/dev/null
			# Zufallszahlen generieren
			cat /dev/urandom | \
			uuencode -m bla | \
			head -19 | \
			sed "s/begin.*//g" | \
			tail -18 | xargs | \
			sed "s/ //g" > ${DIR}/.rand &>/dev/null
			chmod 770 ${DIR}/.rand &>/dev/null
			# allgemeine Konfigurationsdatei erstellen
			KWSSL2RC="${KWSSL_DIR}/${DIR}/${KWSSL2RC_NAME}"
			kwssl_config
		else
			# allgemeine Konfigurationsdatei erstellen, falls nicht vorhanden.
			if [ ! -f "${KWSSL_DIR}/${DIR}/${KWSSL2RC_NAME}" ] ; then
				kwssl_config
			fi
			KWSSL2RC="${KWSSL_DIR}/${DIR}/${KWSSL2RC_NAME}"
		fi
	else
		no_para_msg $0
	fi
}
## }}}
# Funktion (check_helpfile), prueft welche Hilfe Datei angezeigt# {{{
# werden soll, etc..
#
# usage: check_helpfile [ -c | -ca | -subca ]
#
# -c - Benutzer/Server Zertifikate
# -ca - CA
# -subca - SubCA
#
check_helpfile() {
	unset -- H_Opt
	local H_Opt="$1"
	case "$H_Opt" in
		-ca)
			# CA
			CA_TITLE=$(gettext 'erstelle CA')
			HELPFILE="conf_rootca_help conf_defaultca_help"
			;;
		-subca)
			# SubCA
			CA_TITLE=$(gettext 'erstelle SubCA')
			HELPFILE="conf_subca_help conf_defaultca_help"
			;;
		-c)
			# Einstellungen fuer die Erstellung von Benutzer/Server Zertifikaten
			# und Anzeigen bzw. der Hilfedateien.
			CA_TITLE=$(gettext 'erstelle $lv_Cert')
			TITLE="${CA_TITLE}::${gv_Help}"
			if [[ $CONF_SECTION == server_cert ]] ; then
				Ssl_ServerUserName="$lv_Ssl_ServerName"
				HELPFILE="conf_serverca_help conf_defaultca_help"
			else
				Ssl_ServerUserName="$lv_Ssl_UserName"
				HELPFILE="conf_userca_help conf_defaultca_help"
			fi
			# 
			;;
	esac
}
## }}}
# Funktion (search_ca), sucht nach vorhandenen CAs.# {{{
#
# usage: search_ca
#
search_ca() {
	unset -- CA_DIRS
	for i in ${KWSSL_DIR}/*(/N) ; {
		if [ -f ${i}/cacert.pem ] ; then
			CA_DIRS+=( ${i##*/} \"\" )
		fi
	}
}
## }}}
# Funktion (search_cert), Certificate herausfinden, ob gueltig oder nicht # {{{
#
# usage: search_cert [ -u | -v | nichts ]
# -u - ungueltig
# -v  - gueltig
# - - alle
#
search_cert() {
	unset -- Opt CERTS_VAL_M CERTS_NON_VAL_M CERTS_ALL_VAL_M CERTS_FILE CERTS_CN
	local Anz Opt
	Opt="$1"
	# un/gueltige/alle Zertifikate finden
	Anz=0
	while read Val b Serial d Subject ; do
		case "$Opt" in
			-u)
				# ungueltige Certificates herrausfinden
				read_ca_data "${KWSSL_DIR}/${CA_OPEN_NAME}/newcerts/${Serial}.pem"
				case "$lv_Validity" in
					$lv_NoValidity|$lv_RevokeValidity)
						(( Anz++ ))
						CERTS_FILE+=(${KWSSL_DIR}/${CA_OPEN_NAME}/newcerts/${Serial}.pem)
						CERTS_CN+=($COMMONNAME)
						CERTS_NON_VAL_M+=($Anz \"$COMMONNAME $lv_Validity\" off)
						;;
				esac
				;;
			-v)
				# gueltige Certificates herrausfinden
				read_ca_data "${KWSSL_DIR}/${CA_OPEN_NAME}/newcerts/${Serial}.pem"
				case "$lv_Validity" in
					$lv_YesValidity)
						(( Anz++ ))
						CERTS_FILE+=(${KWSSL_DIR}/${CA_OPEN_NAME}/newcerts/${Serial}.pem)
						CERTS_CN+=($COMMONNAME)
						CERTS_VAL_M+=($Anz \"$COMMONNAME $lv_Validity\" off)
						;;
				esac
				;;
			*)
				# alle ((un)gueltige) Certificates herrausfinden
				read_ca_data "${KWSSL_DIR}/${CA_OPEN_NAME}/newcerts/${Serial}.pem"
				(( Anz++ ))
				CERTS_FILE+=(${KWSSL_DIR}/${CA_OPEN_NAME}/newcerts/${Serial}.pem)
				CERTS_CN+=($COMMONNAME)
				CERTS_ALL_VAL_M+=($Anz \"$COMMONNAME $lv_Validity\" off)
				;;
		esac
	done < ${KWSSL_DIR}/${CA_OPEN_NAME}/index.txt
}
## }}}
# Funktion (ca_open), CA oeffnen# {{{
#
# usage: ca_open
#
ca_open() {
	# Funktion (ca_open_menu)# {{{
	CA_OPEN_TITLE="${lv_CA}::${lv_Open}"
	#
	ca_open_menu() {
		CA_OPEN_MENU=($CA_DIRS)
		menubox "$CA_OPEN_TITLE" "$gv_Menupoint" "$CA_OPEN_MENU"
	}
	## }}}
	search_ca
	ca_open_menu
	while [ -n "$gv_Auswahl" ] ; do
		case "$gv_Auswahl" in
			HELP*)
				script_help help
				ca_open_menu
				;;
			*)
				# Auswahl uebernehmen
				CA_OPEN_NAME="$gv_Auswahl"
				KWSSL2RC="${KWSSL_DIR}/${CA_OPEN_NAME}/${KWSSL2RC_NAME}"
				#
				SERIAL=${${(ws:=:)$(openssl x509 -in ${KWSSL_DIR}/${CA_OPEN_NAME}/cacert.pem -noout -serial)}[2]}
				case "$SERIAL" in
					[a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]*)
						MAIN_MENU_OPT="-ca"
						;;
					*)
						MAIN_MENU_OPT="-subca"
						;;
				esac
				break
				;;
		esac
	done
}
## }}}
# Funktion (main_menu)# {{{
#
main_menu() {
	case $MAIN_MENU_OPT in
		-ca|-subca)
    		MAIN_MENU=($lv_Open \"\" $gv_Configuration \"\"
			$gv_Display \"\" \"$lv_CA_Create\" \"\"
			\"$lv_SubCA_Create\" \"\"
			\"$lv_Cert\" \"\"
			\"$lv_CA_Import\" \"\" \"$lv_CA_Export\" \"\"
			\"$lv_CA_Revoke\" \"\" \"$lv_Dh_File\" \"\"
			$gv_Delete \"\" $gv_Exit \"\")
			;;
		*)
    		MAIN_MENU=(\"$lv_CA_Create\" \"\"
			\"$lv_CA_Import\" \"\"
			$gv_Exit \"\")
			;;
	esac
	#
	if [ -z "$CA_OPEN_NAME" ] ; then
		MAIN_TITLE="$gv_None"
	else
		MAIN_TITLE="$CA_OPEN_NAME"
	fi

	if [[ ${#argv} == 1 ]] ; then
		menubox -d "$1" "$MAIN_TITLE" "$gv_Menupoint" "$MAIN_MENU"
	else
		menubox "$MAIN_TITLE" "$gv_Menupoint" "$MAIN_MENU"
	fi
}
# }}}
# Funktion (find_need_files), findet anhand# {{{
# der ../newcerts/Nummer.pem die ../certs/Name.pem
# Datei, die ja den Namen enthaelt
#
# usage: find_need_files FILE
#
find_need_files() {
	if [[ ${#argv} == 1 ]] ; then
		unset -- Found_File
		File="$1"
		Dir="${KWSSL_DIR}/${CA_OPEN_NAME}/certs"
		for i in ${Dir}/*(.N) ; {
			if diff -q $i $File >/dev/null ; then
				Found_File="$i"
				break
			fi
		}
	else
		no_para_msg $0
	fi
}
## }}}
# Funktion (fingerprint)# {{{
#
fingerprint() {
	if [[ ${#argv} == 2 ]] ; then
		local File Dst_File
		File="$1"
		Dst_File="$2"
		echo "Fingerprint (SHA1): `print ${${(ws:=:)${(M)$(openssl x509 -fingerprint -sha1 -in "$File" -noout)##*Fingerprint*}}[2]}`" >> "$Dst_File" &>/dev/null
		echo "Fingerprint (MD5): `print ${${(ws:=:)${(M)$(openssl x509 -fingerprint -md5 -in "$File" -noout)##*Fingerprint*}}[2]}`" >> "$Dst_File" &>/dev/null
		echo "" >> "$Dst_File" &>/dev/null
	else
		no_para_msg $0
	fi
}
## }}}
# Funktion (keylength_input), eingabe der Schluessellaenge (numbits)# {{{
#
# usage: keylength_input
#
keylength_input() {
	KEY_LENGTH_MENU=(1024 \"\" 2048 \"\" 4096 \"\")
	# Funktion (keylength_menu)# {{{
	keylength_menu() {
		if [ -n "$KEYLENGTH" ] ; then
			menubox -d "$KEYLENGTH" "$CA_TITLE" "$gv_Menupoint" "$KEY_LENGTH_MENU"
		else
			menubox "$CA_TITLE" "$gv_Menupoint" "$KEY_LENGTH_MENU"
		fi
	}
	## }}}
	keylength_menu
	while [ -n "$gv_Auswahl" ] ; do
		case "$gv_Auswahl" in
			HELP*) # Hilfe
				script_help "$HELPFILE"
				keylength_menu
				;;
			*) # Auswahl uebernehmen
				KEYLENGTH="$gv_Auswahl"
				break
				;;
		esac
	done
}
## }}}
# Funktion (read_ca_data), einlesen der CA Daten# {{{
#
# usage: read_ca_data FILE
#
read_ca_data() {
	if [[ ${#argv} == 1 ]] ; then
		unset -- SEARCH_INDEX_TXT
		local DataFile File Tmp
		File="$1"
		DataFile="${1##*/}.data"
		# Tmp-Datei anlegen und Variablen mit eingelesenen Werten belegen
		openssl x509 -inform PEM -in $File \
		   -issuer -subject -enddate -noout \
			> ${gv_WorkDir}/${DataFile}
		#
		while read a ; do
			case "$a" in
#				issuer*)
#					# Issuer# {{{
#					SEARCH_INDEX_TXT="${a#*= }"
#					print "${a#*= /}" | tr '/' '\n' | while read d ; do
#						case $d in
#							C=*)
#								COUNTRYCODE="${d#*=}"
#								;;
#							ST=*)
#								COUNTRY="${d#*=}"
#								;;
#							L=*)
#								LOCATION="${d#*=}"
#								;;
#							O=*)
#								ORGANISATION="${d#*=}"
#								;;
#							OU=*)
#								ORGANISATIONUNIT="${d#*=}"
#								;;
#							CN=*)
#								COMMONNAME="${d#*=}"
#								;;
#							emailAddress=*)
#								MAIL="${d#*=}"
#								;;
#						esac
#					done
#					## }}}
#						;;
				subject*)
					# Subject# {{{
					SEARCH_INDEX_TXT="${a#*= }"
					print "${a#*= /}" | tr '/' '\n' | while read d ; do
						case $d in
							C=*)
								COUNTRYCODE="${d#*=}"
								;;
							ST=*)
								COUNTRY="${d#*=}"
								;;
							L=*)
								LOCATION="${d#*=}"
								;;
							O=*)
								ORGANISATION="${d#*=}"
								;;
							OU=*)
								ORGANISATIONUNIT="${d#*=}"
								;;
							CN=*)
								COMMONNAME="${d#*=}"
								;;
							emailAddress=*)
								MAIL="${d#*=}"
								;;
						esac
					done
					## }}}
					;;
				notAfter*)
					# Datum - un/gueltig# {{{
					# CA_OPEN_NAME/index.txt kontrollieren/vergleichen, wegen
					# gueltig und ungueltig.
					# Funktion (check_datetime), gueltig/ungueltig anhand# {{{
					# der Zeitdaten herausfinden
					#
					check_datetime() {
						DATE=$(date +%Y%m%d)
						DATE1=$(date +%H%M%S)
						# Daten von notAfter einlesen
						print ${${(ws:=:)${CHECK_VALUE}}[2,$]} | \
						while read mon day time year Rest ; do
							Monat="$mon"
							Day="$day"
							Year="$year"
							Hour=${${(ws,:,)${time}}[1]}
							Minute=${${(ws,:,)${time}}[2]}
							Second=${${(ws,:,)${time}}[3]}
							# Datum umrechnen
							GESY=$(date -d "$Day $Monat $Year" +%Y%m%d)
							GESH="${Hour}${Minute}${Second}"
							# Ist das aktuelle Datum gleich dem Datum von Not After
							# dann wird die Uhrzeit ueberprueft.
							if [ "$DATE" -eq "$GESY" ] ; then
								# Uhrzeit ueberpruefen
								if [ "$DATE1" -lt "$GESH" ] ; then
									lv_Validity="$lv_YesValidity"
								else
									lv_Validity="$lv_NoValidity"
								fi
							elif [ "$DATE" -gt "$GESY" ] ; then
								lv_Validity="$lv_NoValidity"
							else
								lv_Validity="$lv_YesValidity"
							fi
						done
					}
					## }}}
					######################################
					# TODO:
					# hier gehts weiter
					# herausfinden welche index.txt Datei zur Kontrolle
					# benutzt werden soll.
					######################################
					# Variable CHECK_VALUE ist fuer die Funktion check_datetime
					CHECK_VALUE="$a"
					#
					INDEX_FILE="${KWSSL_DIR}/${CA_OPEN_NAME}/index.txt"
					if [ -s "$INDEX_FILE" ] ; then
						Tmp=${${(ws: :)${(M)${(f)"$(< $INDEX_FILE)"}##*$SEARCH_INDEX_TXT}}[1]}
						case "$Tmp" in
							R)
								# R = widerrufen
								lv_Validity="$lv_RevokeValidity"
								;;
							V|*)
								# V = gueltig, aber trotzdem pruefen.
								#lv_Validity="$lv_YesValidity"
								check_datetime
								;;
						esac
					else
						check_datetime
					fi
					## }}}
					;;
			esac
		done < ${gv_WorkDir}/${DataFile}
		# Verschluesselung herausfinden# {{{
		Tmp=${${(ws,: ,)${(M)${(f)"$(openssl x509 -inform PEM -in $File -text)"}##*Public Key Algorithm*}}[2]}
		if [[ $Tmp == rsaEncryption ]] ; then
			ALG=RSA
		else
			ALG=DSA
		fi
		## }}}
	else
		no_para_msg $0
	fi
}
## }}}
# Funktion (read_openssl_conf)# {{{
#
read_openssl_conf() {
	# mittels awk Daten einlesen# {{{
	unset -- CONF_SECT
	awk -F '= ' '/\[/{if(/'"$CONF_SECTION"'/){found=1}else{found=0}}
		/authorityKeyIdentifier/{if(found){AUTHKEYIDENT=$NF}}
		/basicConstraints/{if(found){BASICCONSTRAINTS=$NF}}
		/crlDistributionPoints/{if(found){CRLDISTPOINT=$NF}}
		/extendedKeyUsage/{if(found){EKEYUSAGE=$NF}}
		/issuerAltName/{if(found){ISSUERALTNAME=$NF}}
		/keyUsage/{if(found){KEYUSAGE=$NF}}
		/nsBaseUrl/{if(found){NSBASEURL=$NF}}
		/nsCaPolicyUrl/{if(found){NSCAPOLICYURL=$NF}}
		/nsCaRevokeUrl/{if(found){NSCAREVOKEURL=$NF}}
		/nsCertType/{if(found){NSCERTTYPE=$NF}}
		/nsComment/{if(found){NSCOMMENT=$NF}}
		/nsRenewalUrl/{if(found){NSRENEWALURL=$NF}}
		/nsRevokeUrl/{if(found){NSREVOKEURL=$NF}}
		/nsSsLServerName/{if(found){NSSSLSERVERNAME=$NF}}
		/subjectAltName/{if(found){SUBJECT_ALTER_NAME=$NF}}
		END{print AUTHKEYIDENT"\n"BASICCONSTRAINTS"\n"CRLDISTPOINT"\n"EKEYUSAGE"\n"ISSUERALTNAME"\n"KEYUSAGE"\n"NSBASEURL"\n"NSCAPOLICYURL"\n"NSCAREVOKEURL"\n"NSCERTTYPE"\n"NSCOMMENT"\n"NSRENEWALURL"\n"NSREVOKEURL"\n"NSSSLSERVERNAME"\n"SUBJECT_ALTER_NAME}' \
		$KWSSL2RC >${gv_WorkDir}/cert_conf
	if [[ $CONF_SECTION == v3_ca ]] ; then
		awk -F '= ' '/\[/{if(/'"ca_ca"'/){found=1}else{found=0}}
			/default_days/{if(found){VALIDITY=$NF}}
			/default_crl_days/{if(found){DEFAULT_REVOKE_DAYS=$NF}}
			END{print VALIDITY"\n"DEFAULT_REVOKE_DAYS}' \
			$KWSSL2RC >> ${gv_WorkDir}/cert_conf
	else
		CONF_SECT="${CONF_SECTION%%_*}_ca"
		awk -F '= ' '/\[/{if(/'"$CONF_SECT"'/){found=1}else{found=0}}
			/default_days/{if(found){VALIDITY=$NF}}
			/default_crl_days/{if(found){DEFAULT_REVOKE_DAYS=$NF}}
			END{print VALIDITY"\n"DEFAULT_REVOKE_DAYS}' \
			$KWSSL2RC >> ${gv_WorkDir}/cert_conf
	fi
	## }}}
	# Werte einlesen
	Anz=1
	while read Value ; do
		case $Anz in
			1)
				AUTHKEYIDENT="$Value"
				(( Anz++ ))
				;;
			2)
				BASICCONSTRAINTS="$Value"
				(( Anz++ ))
				;;
			3)
				CRLDISTPOINT="$Value"
				(( Anz++ ))
				;;
			4)
				# erweiterte Schluesselverwendung (EKEYUSAGE) uebersetzen# {{{
				case "$Value" in
					*::EKEYUSAGE)
						EKEYUSAGE="$lv_Qestion_User"
						;;
					*)
						EKEYUSAGE="$Value"
						;;
				esac
				(( Anz++ ))
				## }}}
				;;
			5)
				ISSUERALTNAME="$Value"
				(( Anz++ ))
				;;
			6)
				# Schluesselverwendung (KEYUSAGE) uebersetzen# {{{
				case "$Value" in
					critical,*keyCertSign,*cRLSign)
						KEYUSAGE="$lv_CertSign_CrlSign_Ca"
						CRITICAL="$lv_Critical"
						;;
					keyCertSign,*cRLSign)
						KEYUSAGE="$lv_CertSign_CrlSign_Ca"
						CRITICAL="$lv_UnCritical"
						;;
					critical,*digitalSignature,*keyEncipherment)
						KEYUSAGE="$lv_Encrypt_DigitalSign"
						CRITICAL="$lv_Critical"
						;;
					digitalSignature,*keyEncipherment)
						KEYUSAGE="$lv_Encrypt_DigitalSign"
						CRITICAL="$lv_UnCritical"
						;;
					critical,*keyCertSign)
						KEYUSAGE="$lv_CertSign_Ca"
						CRITICAL="$lv_Critical"
						;;
					keyCertSign)
						KEYUSAGE="$lv_CertSign_Ca"
						CRITICAL="$lv_UnCritical"
						;;
					critical,*cRLSign)
						KEYUSAGE="$lv_CrlSign_Ca"
						CRITICAL="$lv_Critical"
						;;
					cRLSign)
						KEYUSAGE="$lv_CrlSign_Ca"
						CRITICAL="$lv_UnCritical"
						;;
					critical,*digitalSignature)
						KEYUSAGE="$lv_DigitalSign"
						CRITICAL="$lv_Critical"
						;;
					digitalSignature)
						KEYUSAGE="$lv_DigitalSign"
						CRITICAL="$lv_UnCritical"
						;;
					critical,*keyEncipherment)
						KEYUSAGE="$lv_Encrypt"
						CRITICAL="$lv_Critical"
						;;
					keyEncipherment)
						KEYUSAGE="$lv_Encrypt"
						CRITICAL="$lv_UnCritical"
						;;
					critical,*)
						KEYUSAGE="${Value//*, /}"
						CRITICAL="$lv_Critical"
						;;
					*)
						KEYUSAGE="$Value"
						CRITICAL="$lv_UnCritical"
						;;
				esac
				(( Anz++ ))
				## }}}
				;;
			7)
				NSBASEURL="$Value"
				(( Anz++ ))
				;;
			8)
				NSCAPOLICYURL="$Value"
				(( Anz++ ))
				;;
			9)
				# Variable fuer NSCAREVOKEURL uebersetzen# {{{
				case "$Value" in
					*::NSCAREVOKEURL)
						NSCAREVOKEURL="$lv_Qestion_User"
						;;
					*)
						NSCAREVOKEURL="$Value"
						;;
				esac
				(( Anz++ ))
				## }}}
				;;
			10)
				# Variable NSCERTTYPE uebersetzen# {{{
				case "$Value" in
					sslCA,*emailCA,*objCA)
						NSCERTTYPE="$lv_SMime_SSL_ObjectSign_Ca"
						;;
					sslCA,*objCA)
						NSCERTTYPE="$lv_ObjectSign_SSL_Ca"
						;;
					emailCA,*objCA)
						NSCERTTYPE="$lv_SMime_ObjectSign_Ca"
						;;
					sslCA,*emailCA)
						NSCERTTYPE="$lv_SMime_SSL_Ca"
						;;
					emailCA)
						NSCERTTYPE="$lv_SMime_Ca"
						;;
					objCA)
						NSCERTTYPE="$lv_ObjectSign_Ca"
						;;
					sslCA)
						NSCERTTYPE="$lv_SSL_Ca"
						;;
					server,*client)
						NSCERTTYPE="$lv_SSL_SERVER_CLIENT"
						;;
					client)
						# Anzeige fuer das Menu herausfinden.
						if [[ ${CONF_SECTION%%_*} == server ]] ; then
							NSCERTTYPE="$lv_SSL_CLIENT"
						else
							NSCERTTYPE="$lv_SSL_USER"
						fi
						;;
					server)
						NSCERTTYPE="$lv_SSL_SERVER"
						;;
					objsign)
						NSCERTTYPE="$lv_User_ObjectSign"
						;;
					client,*email,*objsign)
						NSCERTTYPE="$lv_User_Usr_Email_ObjectSign"
						;;
					client,*objsign)
						NSCERTTYPE="$lv_User_Usr_ObjectSign"
						;;
					client,*email)
						NSCERTTYPE="$lv_User_Usr_Smime"
						;;
					email)
						NSCERTTYPE="$lv_User_Smime"
						;;
					*)
						NSCERTTYPE="$Value"
						;;
				esac
				(( Anz++ ))
				## }}}
				;;
			11)
				NSCOMMENT="${Value//\"/\\\"}"
				(( Anz++ ))
				;;
			12)
				# Variable fuer NSRENEWALURL uebersetzen# {{{
				case "$Value" in
					*::NSRENEWALURL)
						NSRENEWALURL="$lv_Qestion_User"
						;;
					*)
						NSRENEWALURL="$Value"
						;;
				esac
				(( Anz++ ))
				## }}}
				;;
			13)
				# Variable fuer NSREVOKEURL uebersetzen# {{{
				case "$Value" in
					*::NSREVOKEURL)
						NSREVOKEURL="$lv_Qestion_User"
						;;
					*)
						NSREVOKEURL="$Value"
						;;
				esac
				(( Anz++ ))
				## }}}
				;;
			14)
				# Variable fuer NSSSLSERVERNAME uebersetzen# {{{
				case "$Value" in
					*::NSSSLSERVERNAME)
						NSSSLSERVERNAME="$lv_Qestion_User"
						;;
					*)
						NSSSLSERVERNAME="$Value"
						;;
				esac
				(( Anz++ ))
				## }}}
				;;
			15)
				# Variable SUBJECT_ALTER_NAME uebersetzen# {{{
				case "$Value" in
					email:copy)
						SUBJECT_ALTER_NAME="$lv_CopyMail"
						;;
					*::SUBJECTALTNAMEIP)
						SUBJECT_ALTER_NAME="$lv_Qestion_User"
						;;
					*)
						SUBJECT_ALTER_NAME="$Value"
						;;
				esac
				(( Anz++ ))
				## }}}
				;;
			16)
				VALIDITY="$Value"
				(( Anz++ ))
				;;
			17)
				DEFAULT_REVOKE_DAYS="$Value"
				;;
		esac
	done < ${gv_WorkDir}/cert_conf
}
## }}}
# Funktion (no_open_ca_msg)# {{{
no_open_ca_msg() {
	MSG=$(gettext 'Es ist keine CA geoeffnet.')
	msgbox "$gv_Info" "$MSG"
}
## }}}
# Funktion (no_ca_msg)# {{{
#
# usage: no_ca_msg CA-Name
no_ca_msg() {
	if [[ ${#argv} == 1 ]] ; then
		local Ca
		unset -- Ca
		Ca="$1"
		MSG=$(gettext 'Es ist keine $Ca vorhanden. Sie muessen erst eine erstellen.')
		msgbox "$gv_Info" "$MSG"
	else
		no_para_msg $0
	fi
}
## }}}
# Funktion (no_cas_msg)# {{{
no_cas_msg() {
	MSG=$(gettext 'Es sind keine CAs bzw. Zertifikate vorhanden.')
	msgbox "$gv_Info" "$MSG"
}
## }}}
# Funktion (no_cas_valid_msg)# {{{
no_cas_valid_msg() {
	MSG=$(gettext 'Es sind keine gueltigen CAs bzw. Zertifikate vorhanden.')
	msgbox "$gv_Info" "$MSG"
}
## }}}
# Funktion (no_cas_nonvalid_msg)# {{{
no_cas_nonvalid_msg() {
	MSG=$(gettext 'Es sind keine ungueltigen CAs bzw. Zertifikate vorhanden.')
	msgbox "$gv_Info" "$MSG"
}
## }}}
# Funktion (ca_existed_msg), Nachricht das diese CA schon existiert# {{{
#
ca_existed_msg() {
	MSG=$(gettext 'Diese CA ($gv_Auswahl) ist schon vorhanden.')
	msgbox "$gv_Info" "$MSG"
}
## }}}
# Funktion (no_need_file_msg)# {{{
no_need_file_msg() {
	MSG=$(gettext 'Es wurde keine CA oder Zertifikat Datei gefunden.')
	msgbox "$gv_Info" "$MSG"
}
## }}}

##################################################################
#
# Hauptprogramm
#
##################################################################

# CAs suchen und zur Auswahl bereitsstellen, oder
# CA erstellen
search_ca
if [ -z "${CA_DIRS[1]}" ] ; then
	conf_ca -ca
else
	ca_open
fi

main_menu
while [ "$gv_Auswahl" ] ; do
	case $gv_Auswahl in
		HELP*)
    	    # Hilfe Messagebox
			script_help help
			main_menu
			;;
		$lv_Open)
			# CA/SubCA oeffnen
			ca_open
			main_menu $lv_Open
			;;
		$gv_Configuration)
			# Konfiguration erstellen# {{{
			autoload -U default_conf
			default_conf
			## }}}
			main_menu $gv_Configuration
			;;
		$gv_Display)
			# CA anschauen# {{{
			###########################################	
			# TODO:
			# Anzeige
			#openssl pkcs12 -info -nokeys -in $i \
			#	-passin pass:${PASSWORD} | less
			###########################################	
			if [ -n "$CA_OPEN_NAME" ] ; then
				if [ -f "${KWSSL_DIR}/${CA_OPEN_NAME}/cacert.pem" ] ; then
					CN_CERT_FILE="${KWSSL_DIR}/${CA_OPEN_NAME}/cacert.pem"
					CN_NAME="$CA_OPEN_NAME"
					# alte Datei loeschen
					rm -f $DISPLAY_FILE &>/dev/null
					# Anzeige Datei fuellen
					echo "################################" >> $DISPLAY_FILE
					echo "$CN_NAME" >> $DISPLAY_FILE
					echo "################################" >> $DISPLAY_FILE
					fingerprint "$CN_CERT_FILE" $DISPLAY_FILE
					echo "" >> $DISPLAY_FILE
					openssl x509 -in "$CN_CERT_FILE" -text >> $DISPLAY_FILE
					echo "" >> $DISPLAY_FILE
					view_file $DISPLAY_FILE
				else
					no_ca_msg $CA_OPEN_NAME
				fi
			else
				no_open_ca_msg
			fi
			## }}}
			main_menu $gv_Display
			;;
		$lv_CA_Create)
			# CAs erstellen# {{{
			conf_ca -ca
			## }}}
			main_menu $lv_CA_Create
			;;
		$lv_SubCA_Create)
			# SubCAs erstellen# {{{
			conf_ca -subca
			## }}}
			main_menu $lv_SubCA_Create
			;;
		$lv_Cert)
			# Zertifikate verwalten bearbeiten.# {{{
			#################################################
			# TODO: noch nicht fertig
			#################################################
			if [ -n "$CA_OPEN_NAME" ] ; then
				# Funktion (cert_menu)# {{{
				#
				CERT_TITLE="${CA_OPEN_NAME}::${lv_Cert}"
				cert_menu() {
		    		CERT_MENU=($gv_Display \"\"
					\"$lv_ServerCA_Create\" \"\"
					\"$lv_UserCA_Create\" \"\"
					\"$lv_Export\" \"\" \"$lv_RevokeValidity\" \"\"
					$gv_Delete \"\" $gv_Back \"\")
					#
					if [[ ${#argv} == 1 ]] ; then
						menubox -d "$1" "$CERT_TITLE" "$gv_Menupoint" "$CERT_MENU"
					else
						menubox "$CERT_TITLE" "$gv_Menupoint" "$CERT_MENU"
					fi
				}
				# }}}
				cert_menu
				while [ -n "$gv_Auswahl" ] ; do
					case "$gv_Auswahl" in
						HELP*)
							script_help cert_help
							cert_menu
							;;
						$gv_Display)
							# Zertifikate anschauen# {{{
							# Funktion (cert_choice_menu)# {{{
							CERT_TITLE="${lv_Cert}::${gv_Display}"
							#
							cert_choice_menu() {
								CERT_MENU=($CERTS_ALL_VAL_M)
								checklist "$CERT_TITLE" "$gv_Menupoint" "$CERT_MENU"
							}
							## }}}
							# alle Zertifikate herraussuchen, ob gueltig oder nicht.
							search_cert
							if [ -n "${CERTS_ALL_VAL_M[1]}" ] ; then
								cert_choice_menu
								while [ "$gv_Auswahl" ] ; do
									case $gv_Auswahl in
										HELP*)
								    	    # Hilfe Messagebox
											script_help cert_help
											cert_choice_menu
											;;
										*)
											# Auswahl anzeigen
											# alte Datei loeschen
											rm -f $DISPLAY_FILE &>/dev/null
											# Anzeige Datei fuellen
											for i in ${=gv_Auswahl} ; {
												CN_CERT_FILE="${CERTS_FILE[i]}"
												CN_NAME="${CERTS_CN[i]}"
												echo "################################" >> $DISPLAY_FILE
												echo "$CN_NAME" >> $DISPLAY_FILE
												echo "################################" >> $DISPLAY_FILE
												fingerprint "$CN_CERT_FILE" $DISPLAY_FILE
												echo "" >> $DISPLAY_FILE
												openssl x509 -in "$CN_CERT_FILE" -text >> $DISPLAY_FILE
												echo "" >> $DISPLAY_FILE
											}
											view_file $DISPLAY_FILE
											break
											;;
									esac
								done
							else
								no_cas_msg
							fi
							## }}}
							cert_menu $gv_Display
							;;
						$lv_ServerCA_Create|$lv_UserCA_Create)
							# Server Zertifikate erstellen# {{{
							if [ -n "$CA_OPEN_NAME" ] ; then
								Menu_Opt="$gv_Auswahl"
								# pruefen ob die $CA_OPEN_NAME (CA) schon existiert
								if [ -f ${KWSSL_DIR}/${CA_OPEN_NAME}/cacert.pem ] ; then
									# Daten der SubCA einlesen.
									read_ca_data "${KWSSL_DIR}/${CA_OPEN_NAME}/cacert.pem"
									# einige Variablen loeschen
									unset -- SUBCAPASSWORD PASSWORD CAPASSWD COMMONNAME
									if [[ $Menu_Opt == $lv_ServerCA_Create ]] ; then
										# openssl.cnf Section auswaehlen
										CONF_SECTION=server_cert
										CONF_SECT=server_ca
									else
										CONF_SECTION=client_cert
										CONF_SECT=client_ca
									fi
									# Zertifikate konfigurieren, ... und erstellen.
									conf_ca -c
								else
									no_ca_msg $CA_OPEN_NAME
								fi
							else
								no_open_ca_msg
							fi
							## }}}
							cert_menu $Menu_Opt
							;;
						$lv_Export)
							# Zertifikate exportieren# {{{
							autoload -U export_files
							CERT_EXPORT_TITLE="${lv_Cert}::${lv_Export}"
							#
							# Funktion (cert_choice_menu)# {{{
							cert_choice_menu() {
								CERT_EXPORT_MENU=($CERTS_VAL_M)
								radiolist "$CERT_EXPORT_TITLE" "$gv_Menupoint" "$CERT_EXPORT_MENU"
							}
							## }}}
							search_cert -v
							if [[ -n ${CERTS_VAL_M[1]} ]] ; then
								cert_choice_menu
								while [ "$gv_Auswahl" ] ; do
									case $gv_Auswahl in
										HELP*)
								    	    # Hilfe Messagebox
											script_help export_ca_help
											cert_choice_menu
											;;
										*)
											# Auswahl der Export Formate,
											# Daten der CA einlesen etc.
											Ex_File="${CERTS_FILE[gv_Auswahl]}"
											find_need_files "$Ex_File"
											if [[ -n $Found_File ]] ; then
												export_files "$Found_File"
											else
												no_need_file_msg
											fi
											break
											;;
									esac
								done
							else
								no_cas_valid_msg
							fi
							## }}}
							cert_menu $lv_Export
							;;
						$lv_RevokeValidity)
							# Zertifikate fuer ungueltig erklaeren
							hier_ist_noch_nichts $lv_RevokeValidity
							cert_menu $lv_RevokeValidity
							;;
						$gv_Delete)
							# Zertifikate loeschen
							hier_ist_noch_nichts $gv_Delete
							cert_menu $gv_Delete
							;;
						$gv_Back)
							break
							;;
					esac
				done
			else
				no_open_ca_msg
			fi
			## }}}
			main_menu $lv_Cert
			;;
		$lv_CA_Import)
			# CA importieren# {{{
			autoload -U ca_certs_import
			ca_certs_import
			## }}}
			main_menu $lv_CA_Import
			;;
		$lv_CA_Export)
			# CA exportieren# {{{
			autoload -U export_files
			if [ -n "$CA_OPEN_NAME" ] ; then
				CERT_EXPORT_TITLE="${CA_OPEN_NAME}::${lv_CA_Export}"
				Ex_File="${KWSSL_DIR}/${CA_OPEN_NAME}/cacert.pem"
				export_files "$Ex_File"
			else
				no_open_ca_msg
			fi
			## }}}
			main_menu $lv_CA_Export
			;;
		$lv_CA_Revoke)
			# Zertifikate einer CA für ungueltig erklaeren# {{{
			if [ -n "$CA_OPEN_NAME" ] ; then
				GROUND=${GROUND:-unspecified}
				CERT_REVOKE_TITLE="${CA_OPEN_NAME}::${lv_CA_Revoke}"
				# Funktion (cert_revoke_menu)# {{{
				cert_revoke_menu() {
					CERT_MENU=($CERTS_VAL_M)
					radiolist "$CERT_REVOKE_TITLE" "$gv_Menupoint" "$CERT_MENU"
				}
				## }}}
				# Funktion (ground_revoke_menu)# {{{
				#
				ground_revoke_menu() {
					GROUND_REVOKE_MENU=(unspecified \"\" on
					KeyCompromise \"\" off
					CaCompromise \"\" off
					AffiliationChanged \"\" off 
					Superseded \"\" off CessationOfOperation \"\" off
					CertificatHold \"\" off)
					radiolist "$CERT_REVOKE_TITLE" "$gv_Menupoint" "$GROUND_REVOKE_MENU"
				}
				## }}}
				# Funktion (conf_revoke_menu)# {{{
				#
				lv_Ground=$(gettext 'Grund')
				#
				conf_revoke_menu() {
					CONF_REVOKE_MENU=(\"$lv_Ssl_Password\" \"$CA_PASS\"
					$lv_Ground \"$GROUND\" $gv_Save \"\" $gv_Back \"\")
					menubox "$CERT_REVOKE_TITLE" "$gv_Menupoint" "$CONF_REVOKE_MENU"
				}
				## }}}
				search_cert -v
				if [ -n "${CERTS_VAL_M[1]}" ] ; then
					cert_revoke_menu
					while [ "$gv_Auswahl" ] ; do
						case $gv_Auswahl in
							HELP*)
					    	    # Hilfe Messagebox
								script_help ca_revoke_help
								cert_revoke_menu
								;;
							*)
								# Revoke Menue
								set -x
								REVOKE_FILE="${CERTS_FILE[gv_Auswahl]}"
								set +x
								conf_revoke_menu
								while [ "$gv_Auswahl" ] ; do
									case $gv_Auswahl in
										HELP*)
								    	    # Hilfe Messagebox
											script_help ca_revoke_help
											conf_revoke_menu
											;;
										"$lv_Ssl_Password")
											# Passwort fuer das Zertifikat eingeben# {{{
											CERT_REVOKE_MSG=$(gettext 'Geben Sie bitte das Password fuer dieses Zertifikat ein.')
											password "$CERT_REVOKE_TITLE" "$CERT_REVOKE_MSG"
											if [ -n "$PASSPHRASE" ] ; then
												password_display "$PASSPHRASE"
												if [ -n "$gv_Star_Passphrase" ] ; then
													CA_PASS="$gv_Star_Passphrase"
												else
													unset -- CA_PASS PASSPHRASE
												fi
											else
												unset -- CA_PASS PASSPHRASE
											fi
											## }}}
											conf_revoke_menu $lv_Ssl_Password
											;;
										$lv_Ground)
											# Grund angeben/auswaehlen# {{{
											ground_revoke_menu
											while [ -n "$gv_Auswahl" ] ; do
												case $gv_Auswahl in
													HELP*)
											    	    # Hilfe Messagebox
														script_help ca_revoke_help
														ground_revoke_menu
														;;
													*)
														# Auswahl uebernehmen
														GROUND="$gv_Auswahl"
														break
														;;
												esac
											done
											## }}}
											conf_revoke_menu $lv_Ground
											;;
										$gv_Save)
											# CAs und Zertifikate widerrufen# {{{
											cd ${KWSSL_DIR}/${CA_OPEN_NAME}
											# Ist REVOKE_FILE gleich einer SubCA
											# (cacert.pem) muessen die Schluessel von
											# RootCA genommen werden.
											##############################################
											# TODO: RootCA
											##############################################
											if [[ $MAIN_MENU_OPT == -subca ]] ; then
												if [ -n "$PASSPHRASE" ] ; then
													openssl ca -config ${KWSSL_DIR}/${CA_OPEN_NAME}/${KWSSL2RC_NAME} \
														-batch -name ca_ca \
														-revoke $REVOKE_FILE \
														-passin pass:${PASSPHRASE} || prog_failure
													openssl ca -config ${KWSSL_DIR}/${CA_OPEN_NAME}/${KWSSL2RC_NAME} \
														-batch -name ca_ca \
														-gencrl -out crl/crl.pem \
														-passin pass:${PASSPHRASE} || prog_failure
													#
													unset -- PASSPHRASE CA_PASS
												else
													MSG=$(gettext 'Sie muessen ein Passwort eingeben.')
													msgbox "$gv_Info" "$MSG"
												fi

											else
												openssl ca -config $KWSSL2RC \
													-batch \
													-revoke $REVOKE_FILE \
													-passin pass:${PASSPHRASE} || prog_failure
													#-batch -name $CONF_SECT \
												openssl ca -config $KWSSL2RC \
													-batch \
													-gencrl -out crl/crl.pem \
													-passin pass:${PASSPHRASE} || prog_failure
												#
												unset -- PASSPHRASE CA_PASS
											fi
											## }}}
											break
											;;
										$gv_Back)
											break
											;;
									esac
								done
								#
								break
								;;
						esac
					done
				else
					no_cas_valid_msg
				fi
			else
				no_open_ca_msg
			fi
			## }}}
			main_menu $lv_CA_Revoke
			;;
		$lv_Dh_File)
			# Diffie Hellman Parameter Datei erzeugen# {{{
			########################################
			# TODO:
			# Datei erzeugen oder in Zertifikat
			# hinzufuegen?
			########################################
			# Funktion (dh_menu)# {{{
			#
			KEYLENGTH="1024"
			#
			dh_menu() {
				DH_FILENAME="${DH_FILENAME:-${HOME}/dh${KEYLENGTH}.pem}"
				#
				DH_TITLE="$lv_Dh_File"
	    		DH_MENU=($lv_Filename \"$DH_FILENAME\"
				$lv_Ssl_Key_length \"$KEYLENGTH\"
				$gv_Create \"\"
				$gv_Back \"\")
				#
				if [[ ${#argv} == 1 ]] ; then
					menubox -d "$1" "$DH_TITLE" "$gv_Menupoint" "$DH_MENU"
				else
					menubox "$DH_TITLE" "$gv_Menupoint" "$DH_MENU"
				fi
			}
			# }}}
			dh_menu
			while [ -n "$gv_Auswahl" ] ; do
				case "$gv_Auswahl" in
					HELP*)
						script_help dh_help
						dh_menu
						;;
					$lv_Filename)
						# Dateiname eingeben# {{{
						DH_FILENAME_MSG=$(gettext 'Geben Sie den Dateinamen ein.')
						inputbox "$lv_Filename" "$DH_FILENAME_MSG" "$DH_FILENAME"
						if [ -n "$gv_Auswahl" ] ; then
							DH_FILENAME="$gv_Auswahl"
						else
							DH_FILENAME="${HOME}/dh${KEYLENGTH}.pem"
						fi
						## }}}
						dh_menu $lv_Filename
						;;
					$lv_Ssl_Key_length)
						# Schluessellaenge (numbits) auswaehlen# {{{
						#
						# HELPFILE belegen fuer keylength_input.
						HELPFILE="dh_help"
						keylength_input
						## }}}
						dh_menu $lv_Ssl_Key_length
						;;
					$gv_Create)
						# Diffie Hellman Datei erstellen.# {{{
						if [ -n "$DH_FILENAME" -a -f "$DH_FILENAME" ] ; then
							MSG=$(gettext 'Die Datei "$DH_FILENAME" ist schon vorhanden.\n\nSoll sie ueberschrieben werden ($gv_Yes/$gv_No)?')
							yesno "$gv_Info" "$MSG"
							if [ "$?" = 0 ] ; then
								openssl dhparam -out "$DH_FILENAME" $KEYLENGTH || prog_failure
							fi
							break
						elif [ -n "$DH_FILENAME" -a ! -f "$DH_FILENAME" ] ; then
							openssl dhparam -out "$DH_FILENAME" $KEYLENGTH || prog_failure
							break
						else
							MSG=$(gettext 'Sie muessen mindestens den Menupunkt $lv_Filename mit einem Wert belegen.')
							msgbox "$gv_Info" "$MSG"
							dh_menu $lv_Filename
						fi
						## }}}
						;;
					$gv_Back)	break
						;;
				esac
			done
			## }}}
			main_menu $lv_Dh_File
			;;
		$gv_Delete)
			# CAs loeschen# {{{
			if [ -n "$CA_OPEN_NAME" ] ; then
				unset -- $UNSET
				# Funktion (del_cert_choice_menu)# {{{
				CERT_TITLE="${CA_OPEN_NAME}::${gv_Delete}"
				del_cert_choice_menu() {
					DEL_CERT_MENU=($CERTS_NON_VAL_M)
					checklist "$CERT_TITLE" "$gv_Menupoint" "$DEL_CERT_MENU"
				}
				## }}}
				# nach $KWSSL_DIR wechseln
				if [[ $CA_OPEN_NAME == RootCA ]] ; then
					# komplette kwssl2 PKI Struktur loeschen
					rm -rfv ${KWSSL_DIR}/* >&/dev/null
				else
					search_cert -u
					if [ -n "${CERTS_NON_VAL_M[1]}" ] ; then
						del_cert_choice_menu
						while [ "$gv_Auswahl" ] ; do
							case "$gv_Auswahl" in
								HELP*)
						    	    # Hilfe Messagebox
									script_help main_help
									del_cert_choice_menu
									;;
								*)
									# Auswahl uebernehmen# {{{
									cd $KWSSL_DIR
									for i in ${=gv_Auswahl} ; {
										local File
										File="${i%%.*}"
										if [[ $File == cacert ]] ; then
											rm -rfv ./${CA_OPEN_NAME} >&/dev/null
										else
											rm -rfv ./${CA_OPEN_NAME}/${File}.* \
											./${CA_OPEN_NAME}/req/${File}.* \
											./${CA_OPEN_NAME}/${File}.* \
											./${CA_OPEN_NAME}/certs/${File}.* \
											./${CA_OPEN_NAME}/keys/${File}.* >&/dev/null
										fi
									}
									## }}}
									unset -- File
									break
									;;
							esac
						done
					else
						no_cas_nonvalid_msg
					fi
				fi
			else
				no_open_ca_msg
			fi
			## }}}
			main_menu $gv_Delete
			;;
		$gv_Exit)	break
			;;
	esac
done	
#
exit 0
