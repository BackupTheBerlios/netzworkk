# Funktion (kwssl_ca), erstellt neue CAs# {{{
#
# usage: kwssl_ca [ -r | -s ]
# -r - RootCA
# -s - SubCA/Server-, Benutzer Zertifikate
#
kwssl_ca() {
	unset -- $UNSET
	local Opt
	Opt="$1"
	#
	case "$Opt" in
		-r)	SUBDIR=RootCA
			;;
	esac
	#
	# Variablen# {{{
	DEFAULT_CONF_TITLE="$gv_Configuration"
	DEFAULT_URL_MSG=$(gettext 'URL Eingabe')
	lv_Server_Ca=$(gettext 'Server Zertifikate')
	lv_User_Ca=$(gettext 'Benutzer Zertifikate')
	lv_Ca_Certs=$(gettext 'CA Zertifikate')
	lv_Revokes=$(gettext 'Widerrufslisten')
	lv_Revoke_Days=$(gettext 'Standardtage')
	lv_Filename=$(gettext 'Dateiname')
	#
	lv_SubjectAlternateName=$(gettext 'Subject Alternative Name')
	lv_NsCertType=$(gettext 'Netscape Zertifikatstyp')
	lv_Ns_Ssl_ServerName=$(gettext 'Netscape SSL Servername')
	lv_KeyUsage=$(gettext 'Schluesselverwendung')
	lv_EKeyUsage=$(gettext 'erweiterte Schluesselverwendung')
	lv_Critical_Ca=$(gettext 'kritisch oder nicht')
	lv_NsRevocationUrl=$(gettext 'Netscape Widerrufs URL')
	lv_NsRenewalUrl=$(gettext 'Netscape Erneuerungs URL')
	lv_NsCaRevocationUrl=$(gettext 'Netscape CA Widerrufs URL')
	lv_NsComment=$(gettext 'Netscape Kommentar')
	lv_CrlDistributionPoints=$(gettext 'crlDistributionPoints')
	lv_AuthKeyIdent=$(gettext 'authorityKeyIdentifier')
	lv_IssuerAltName=$(gettext 'issuerAltName')
	lv_NsBaseUrl=$(gettext 'nsBaseUrl')
	lv_NsPolicyUrl=$(gettext 'nsPolicyUrl')
	lv_NsCaPolicyUrl=$(gettext 'nsCaPolicyUrl')
	lv_BasicConstraints=$(gettext 'basicConstraints')
	#
	lv_CopyMail=$(gettext 'Kopiere Email')
	lv_Qestion_User=$(gettext 'Frage Benutzer')
	lv_Critical=$(gettext 'kritisch')
	lv_UnCritical=$(gettext 'unkritisch')
	lv_SSL_Ca=$(gettext 'SSL CA')
	lv_SSL_SERVER=$(gettext 'SSL Server')
	lv_SSL_CLIENT=$(gettext 'SSL Client')
	lv_SSL_USER=$(gettext 'SSL Benutzer')
	lv_SSL_SERVER_CLIENT=$(gettext 'SSL Server, SSL Client')
	lv_SMime_Ca=$(gettext 'S/MIME CA')
	lv_ObjectSign_Ca=$(gettext 'Object Signierende CA')
	lv_SMime_SSL_Ca=$(gettext 'SSL CA, S/MIME CA')
	lv_ObjectSign_SSL_Ca=$(gettext 'SSL CA, Object Signierende CA')
	lv_SMime_ObjectSign_Ca=$(gettext 'S/MIME, Object Signierende CA')
	lv_SMime_SSL_ObjectSign_Ca=$(gettext 'SSL CA, S/MIME CA, Objekt Signierende CA')
	lv_CertSign_Ca=$(gettext 'Zertifikate signieren')
	lv_CrlSign_Ca=$(gettext 'CRL signieren')
	lv_CertSign_CrlSign_Ca=$(gettext 'Zertifikate signieren, CRL signieren')
	lv_DigitalSign=$(gettext 'Digitale Signatur')
	lv_Encrypt=$(gettext 'Verschluesselung')
	lv_Encrypt_DigitalSign=$(gettext 'Verschluesselung, Digitale Signatur')
	lv_User_ObjectSign=$(gettext 'Object Signieren')
	lv_User_Smime=$(gettext 'Email S/MIME')
	lv_User_Usr_Smime=$(gettext 'SSL Benutzer, Email S/MIME')
	lv_User_Usr_ObjectSign=$(gettext 'SSL Benutzer, Object Signieren')
	lv_User_Usr_Email_ObjectSign=$(gettext 'SSL Benutzer, Email, Object Signieren')
	lv_BasicConstraints=$(gettext 'basicConstraints')
	#
	SAVE_MSG=$(gettext 'Geben Sie den Namen fuer die lokale Speicherung ein.')
	#
	DEFAULT_REVOKE_DAYS=${DEFAULT_REVOKE_DAYS:-30}
	VALIDITY=${VALIDITY:-3650}
	SUBJECT_ALTER_NAME=${SUBJECT_ALTER_NAME:-$lv_CopyMail}
	NSCERTTYPE=${NSCERTTYPE:-$lv_SMime_SSL_Ca}
	KEYUSAGE=${KEYUSAGE:-$lv_CertSign_CrlSign_Ca}
	NSCOMMENT=${NSCOMMENT:-"$gv_ScriptName Generated Certificate"}
	#
	DIGEST="${DIGEST:-SHA-1}"
	CA_NAME=${CA_NAME:-$SUBDIR}
	# Standard Passphrasen Laenge ist 10 Zeichen lang
	# wenn keine Passphrase manuell eingegeben wurde.
	PASSWD_LENGTH="${PASSWD_LENGTH:-10}"
	#
	## }}}
	# Funktion (fingerprint)# {{{
	#
	fingerprint() {
		if [[ ${#argv} == 2 ]] ; then
			local File Dst_File
			File="$1"
			Dst_File="$2"
			echo "Fingerprint (SHA1): `print ${${(ws:=:)${(M)$(openssl x509 -fingerprint -sha1 -in "$File" -noout)##*Fingerprint*}}[2]}`" >> "$Dst_File" &>/dev/null
			echo "Fingerprint (MD5): `print ${${(ws:=:)${(M)$(openssl x509 -fingerprint -md5 -in "$File" -noout)##*Fingerprint*}}[2]}`" >> "$Dst_File" &>/dev/null
			echo "" >> "$Dst_File" &>/dev/null
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (read_ca_data), einlesen der CA Daten# {{{
	#
	read_ca_data() {
		if [[ ${#argv} == 1 ]] ; then
			unset -- SEARCH_INDEX_TXT
			local DataFile File Tmp
			File="$1"
			DataFile="${1##*/}.data"
			# Tmp-Datei anlegen und Variablen mit eingelesenen Werten belegen
			openssl x509 -inform PEM -in $File \
			   -issuer -subject -enddate -noout \
				> ${gv_WorkDir}/${DataFile}
			#
			while read a ; do
				case "$a" in
#					issuer*)
#						# Issuer# {{{
#						SEARCH_INDEX_TXT="${a#*= }"
#						for d in `print ${${(ws:/:)${a}}[2,$]}` ; {
#							case $d in
#								C=*)
#									COUNTRYCODE="${d#*=}"
#									;;
#								ST=*)
#									COUNTRY="${d#*=}"
#									;;
#								L=*)
#									LOCATION="${d#*=}"
#									;;
#								O=*)
#									ORGANISATION="${d#*=}"
#									;;
#								OU=*)
#									ORGANISATIONUNIT="${d#*=}"
#									;;
#								CN=*)
#									COMMONNAME="${d#*=}"
#									;;
#								emailAddress=*)
#									MAIL="${d#*emailAddress=}"
#									;;
#							esac
#						}
#						## }}}
#						;;
					subject*)
						# Issuer# {{{
						SEARCH_INDEX_TXT="${a#*= }"
						for d in `print ${${(ws:/:)${a}}[2,$]}` ; {
							case $d in
								C=*)
									COUNTRYCODE="${d#*=}"
									;;
								ST=*)
									COUNTRY="${d#*=}"
									;;
								L=*)
									LOCATION="${d#*=}"
									;;
								O=*)
									ORGANISATION="${d#*=}"
									;;
								OU=*)
									ORGANISATIONUNIT="${d#*=}"
									;;
								CN=*)
									COMMONNAME="${d#*=}"
									;;
								emailAddress=*)
									MAIL="${d#*emailAddress=}"
									;;
							esac
						}
						## }}}
						;;
					notAfter*)
						# Datum - un/gueltig# {{{
						# SUBDIR/index.txt kontrollieren/vergleichen, wegen
						# gueltig und ungueltig.
						# Funktion (check_datetime), gueltig/ungueltig anhand# {{{
						# der Zeitdaten herausfinden
						#
						check_datetime() {
							DATE=$(date +%Y%m%d)
							DATE1=$(date +%H%M%S)
							# Daten von notAfter einlesen
							print ${${(ws:=:)${CHECK_VALUE}}[2,$]} | \
							while read mon day time year Rest ; do
								Monat="$mon"
								Day="$day"
								Year="$year"
								Hour=${${(ws,:,)${time}}[1]}
								Minute=${${(ws,:,)${time}}[2]}
								Second=${${(ws,:,)${time}}[3]}
								# Datum umrechnen
								GESY=$(date -d "$Day $Monat $Year" +%Y%m%d)
								GESH="${Hour}${Minute}${Second}"
								# Ist das aktuelle Datum gleich dem Datum von Not After
								# dann wird die Uhrzeit ueberprueft.
								if [ "$DATE" -eq "$GESY" ] ; then
									# Uhrzeit ueberpruefen
									if [ "$DATE1" -lt "$GESH" ] ; then
										lv_Validity="$lv_YesValidity"
									else
										lv_Validity="$lv_NoValidity"
									fi
								elif [ "$DATE" -gt "$GESY" ] ; then
									lv_Validity="$lv_NoValidity"
								else
									lv_Validity="$lv_YesValidity"
								fi
							done
						}
						## }}}
						# herausfinden welche index.txt Datei zur Kontrolle
						# benutzt werden soll.
						CHECK_VALUE="$a"
						if [ "$SUBDIR" != RootCA ] && [[ ${File##*/} == cacert.pem ]] ; then
							INDEX_FILE="${KWSSL_DIR}/RootCA/index.txt"
						else
							INDEX_FILE="${File%/*}/index.txt"
						fi
						#
						if [ -s "$INDEX_FILE" ] ; then
							Tmp=${${(ws: :)${(M)${(f)"$(< $INDEX_FILE)"}##*$SEARCH_INDEX_TXT}}[1]}
							case "$Tmp" in
								R)
									# R = widerrufen
									lv_Validity="$lv_RevokeValidity"
									;;
								V|*)
									# V = gueltig, aber trotzdem pruefen.
									#lv_Validity="$lv_YesValidity"
									check_datetime
									;;
							esac
						else
							check_datetime
						fi
						## }}}
						;;
				esac
			done < ${gv_WorkDir}/${DataFile}
			# Verschluesselung herausfinden# {{{
			Tmp=${${(ws,: ,)${(M)${(f)"$(openssl x509 -inform PEM -in $File -text)"}##*Public Key Algorithm*}}[2]}
			if [[ $Tmp == rsaEncryption ]] ; then
				ALG=RSA
			else
				ALG=DSA
			fi
			## }}}
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (search_ca), CAs herausfinden# {{{
	#
	# usage: search_ca [ -u | -v | nichts ] [ CA_SUBDIR ]
	# -u - unvalid
	# -v - valid
	# nichts - all
	# CA_SUBDIR - Verzeichnis unterhalb von $KWSSL_DIR.
	#
	search_ca() {
		if [ "${#argv}" -ge 1 ] ; then
			unset -- CERTS_VAL_M CERTS_NON_VAL_M CERTS_ALL_VAL_M Validity
			local File Validity Anz
			#
			case "$1" in
				-u)
					# ungueltige Zertifikate finden
					if [ -d ${KWSSL_DIR}/${2} ] ; then
						cd ${KWSSL_DIR}/${2}
						#for i in *.cert.pem(.N) *.pkcs12.p12(.N) ; {
						for i in *cert.pem(.N) ; {
							File="$i"
							read_ca_data "${KWSSL_DIR}/${2}/$File"
							Validity="$lv_Validity"
							case "$Validity" in
								$lv_NoValidity|$lv_RevokeValidity)
									CERTS_NON_VAL_M+=($File \"$Validity\" off)
									;;
							esac
						}
					fi
					;;
				-v)
					# gueltige Zertifikate finden
					if [ -d ${KWSSL_DIR}/${2} ] ; then
						cd ${KWSSL_DIR}/${2}
						for i in *cert.pem(.N) ; {
							File="$i"
							read_ca_data "${KWSSL_DIR}/${2}/${File}"
							Validity="$lv_Validity"
							if [[ $Validity == $lv_YesValidity ]] ; then
								CERTS_VAL_M+=($File \"$Validity\" off)
							fi
						}
					fi
					;;
				*)
					# alle Zertifikate finden
					# Die Variable lv_Validity besitzt
					# mehrere Werte.
					if [ -d ${KWSSL_DIR}/${1} ] ; then
						cd ${KWSSL_DIR}/${1}
						for i in *cert.pem(.N) ; {
							File="$i"
							read_ca_data "${KWSSL_DIR}/${1}/$File"
							Validity="$lv_Validity"
							CERTS_ALL_VAL_M+=($File \"$Validity\" off)
						}
					fi
					;;
			esac
		else
			no_para_msg $0
		fi
	}
	## }}}
	# Funktion (no_cas_msg)# {{{
	no_cas_msg() {
		MSG=$(gettext 'Es sind keine CAs bzw. Zertifikate vorhanden.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	# Funktion (no_cas_valid_msg)# {{{
	no_cas_valid_msg() {
		MSG=$(gettext 'Es sind keine gueltigen CAs bzw. Zertifikate vorhanden.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	# Funktion (no_cas_nonvalid_msg)# {{{
	no_cas_nonvalid_msg() {
		MSG=$(gettext 'Es sind keine ungueltigen CAs bzw. Zertifikate vorhanden.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	# Funktion (no_subdir_msg)# {{{
	no_subdir_msg() {
		MSG=$(gettext 'Es ist keine SubCA geoeffnet.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	# Funktion (keylength_input), eingabe der Schluessellaenge (numbits)# {{{
	#
	# usage: keylength_input
	#
	keylength_input() {
		KEY_LENGTH_MENU=(1024 \"\" 2048 \"\" 4096 \"\")
		# Funktion (keylength_menu)# {{{
		keylength_menu() {
			if [ -n "$KEYLENGTH" ] ; then
				menubox -d "$KEYLENGTH" "$CA_TITLE" "$gv_Menupoint" "$KEY_LENGTH_MENU"
			else
				menubox "$CA_TITLE" "$gv_Menupoint" "$KEY_LENGTH_MENU"
			fi
		}
		## }}}
		keylength_menu
		while [ -n "$gv_Auswahl" ] ; do
			case "$gv_Auswahl" in
				HELP*) # Hilfe
					script_help "$HELPFILE"
					keylength_menu
					;;
				*) # Auswahl uebernehmen
					KEYLENGTH="$gv_Auswahl"
					break
					;;
			esac
		done
	}
	## }}}
	# Funktion (main_ca_menu)# {{{
	#
	main_ca_menu() {
		case $Opt in
			-r)
	    		MAIN_CA_MENU=($gv_Configuration \"\"
				$gv_Display \"\" $gv_Create \"\"
				\"$lv_CA_Import\" \"\" \"$lv_CA_Export\" \"\"
				\"$lv_Dh_File\" \"\"
				$gv_Delete \"\" $gv_Back \"\")
				;;
			-s)
	    		MAIN_CA_MENU=($lv_Open \"\" $gv_Configuration \"\"
				$gv_Display \"\" $gv_Create \"\"
				\"$lv_ServerCA_Create\" \"\"
				\"$lv_UserCA_Create\" \"\"
				\"$lv_CA_Import\" \"\"
				\"$lv_CA_Export\" \"\" \"$lv_CA_Revoke\" \"\"
				\"$lv_Dh_File\" \"\"
				$gv_Delete \"\" $gv_Back \"\")
				;;
		esac
		#
		if [ -z "$SUBDIR" ] ; then
			MAIN_CA_TITLE="$lv_SubCa"
		else
			MAIN_CA_TITLE="$SUBDIR"
		fi
		if [[ ${#argv} == 1 ]] ; then
			menubox -d "$1" "$MAIN_CA_TITLE" "$gv_Menupoint" "$MAIN_CA_MENU"
		else
			menubox "$MAIN_CA_TITLE" "$gv_Menupoint" "$MAIN_CA_MENU"
		fi
	}
	# }}}
	# Funktion (subca_existed_msg), Nachricht das diese SubCA schon existiert# {{{
	#
	subca_existed_msg() {
		MSG=$(gettext 'Diese SubCA ($gv_Auswahl) ist schon vorhanden.')
		msgbox "$gv_Info" "$MSG"
	}
	## }}}
	#
	main_ca_menu
	while [ "$gv_Auswahl" ] ; do
		case $gv_Auswahl in
			HELP*)
	    	    # Hilfe Messagebox
				script_help main_ca_help
				main_ca_menu
				;;
			$lv_Open)
				# SubCa oeffnen# {{{
				# SubCas herraus finden# {{{
				unset -- SUBCAS_E
				cd $KWSSL_DIR
				for i in *~*RootCA(/N) ; {
					if [ -f ${i}/cacert.pem ] ; then
						SUBCAS_E+=( $i \"\" )
					fi
				}
				## }}}
				if [ -n "${SUBCAS_E[1]}" ] ; then
					# Funktion (subca_choice_menu)# {{{
					SUBCA_TITLE="${lv_CA}::${lv_Open}"
					#
					subca_choice_menu() {
						SUBCA_MENU=($SUBCAS_E)
						menubox "$SUBCA_TITLE" "$gv_Menupoint" "$SUBCA_MENU"
					}
					## }}}
					subca_choice_menu
					while [ -n "$gv_Auswahl" ] ; do
						case "$gv_Auswahl" in
							HELP*)
								script_help main_ca_help
								subca_choice_menu
								;;
							*)
								# Auswahl uebernehmen
								SUBDIR="$gv_Auswahl"
								KWSSL2RC="${KWSSL_DIR}/${gv_Auswahl}/${KWSSL2RC_NAME}"
								break
								;;
						esac
					done
				else
					no_cas_msg
				fi
				## }}}
				main_ca_menu $lv_Open
				;;
			$gv_Configuration)
				# Konfiguration erstellen# {{{
				autoload -U default_conf
				default_conf
				## }}}
				main_ca_menu $gv_Configuration
				;;
			$gv_Display)
				# CA anschauen# {{{
				###########################################	
				# TODO:
				# Anzeige
				#openssl pkcs12 -info -nokeys -in $i \
				#	-passin pass:${PASSWORD} | less
				###########################################	
				if [ -n "$SUBDIR" -a "$SUBDIR" = RootCA ] ; then
					cd ${KWSSL_DIR}/${SUBDIR}
					# RootCA# {{{
					if [ -f cacert.pem ] ; then
						# alte Datei loeschen
						rm -f $DISPLAY_FILE &>/dev/null
						# Anzeige Datei füllen
						echo "################################" >> $DISPLAY_FILE
						echo "$SUBDIR" >> $DISPLAY_FILE
						echo "################################" >> $DISPLAY_FILE
						fingerprint cacert.pem $DISPLAY_FILE
						echo "" >> $DISPLAY_FILE
						openssl x509 -in cacert.pem -text >> $DISPLAY_FILE
						echo "" >> $DISPLAY_FILE
						view_file $DISPLAY_FILE
					else
						no_ca_msg RootCA
					fi
					## }}}
				elif [ -n "$SUBDIR" ] ; then
					# Funktion (cert_choice_menu)# {{{
					CERT_TITLE="${SUBDIR}::${lv_CA}::${gv_Display}"
					#
					cert_choice_menu() {
						CERT_MENU=($CERTS_ALL_VAL_M)
						checklist "$CERT_TITLE" "$gv_Menupoint" "$CERT_MENU"
					}
					## }}}
					#
					search_ca $SUBDIR
					if [ -n "${CERTS_ALL_VAL_M[1]}" ] ; then
						cert_choice_menu
						while [ "$gv_Auswahl" ] ; do
							case $gv_Auswahl in
								HELP*)
						    	    # Hilfe Messagebox
									script_help main_ca_help
									cert_choice_menu
									;;
								*)
									# Auswahl anzeigen
									# alte Datei loeschen
									rm -f $DISPLAY_FILE &>/dev/null
									# Anzeige Datei fuellen
									for i in  ${=gv_Auswahl} ; {
										echo "################################" >> $DISPLAY_FILE
										echo "$i" >> $DISPLAY_FILE
										echo "################################" >> $DISPLAY_FILE
										fingerprint "$i" $DISPLAY_FILE
										echo "" >> $DISPLAY_FILE
										openssl x509 -in "$i" -text >> $DISPLAY_FILE
										echo "" >> $DISPLAY_FILE
	
										# Anzeige
										#openssl pkcs12 -info -nokeys -in $i \
										#	-passin pass:${PASSWORD} | less
									}
									view_file $DISPLAY_FILE
									break
									;;
							esac
						done
					else
						no_cas_msg
					fi
				else
					no_subdir_msg
				fi
				## }}}
				main_ca_menu $gv_Display
				;;
			$gv_Create)
				# CAs erstellen# {{{
				if [[ $SUBDIR == RootCA ]] ; then
					if [ -f ${KWSSL_DIR}/${SUBDIR}/cacert.pem ] ; then
						# Falls die CA schon existiert nachfragen, ob
						# diese ersetzt werden soll.
						MSG=$(gettext 'Diese CA ($SUBDIR) ist schon vorhanden. Soll sie neu erstellt werden (ja/nein)?')
						yesno "$gv_Info" "$MSG"
						if [ "$?" = 0 ] ; then
							unset -- PASSWORD CAPASSWD COMMONNAME
							conf_ca $Opt
						fi
					else
						conf_ca $Opt
					fi
				else
					# RootCA Daten einlesen.
					read_ca_data "${KWSSL_DIR}/RootCA/cacert.pem"
					# einige Variablen loeschen.
					unset -- ROOTCAPASSWORD PASSWORD CAPASSWD COMMONNAME
					conf_ca $Opt
				fi
				## }}}
				main_ca_menu $gv_Create
				;;
			$lv_ServerCA_Create|$lv_UserCA_Create)
				# Server Zertifikate erstellen# {{{
				if [ -n "$SUBDIR" ] ; then
					Menu_Opt="$gv_Auswahl"
					autoload -U conf_ca
					# pruefen ob die $SUBDIR (CA) schon existiert
					if [ -f ${KWSSL_DIR}/${SUBDIR}/cacert.pem ] ; then
						# Daten der SubCA einlesen.
						read_ca_data "${KWSSL_DIR}/${SUBDIR}/cacert.pem"
						# einige Variablen loeschen
						unset -- SUBCAPASSWORD PASSWORD CAPASSWD COMMONNAME
						if [[ $Menu_Opt == $lv_ServerCA_Create ]] ; then
							# openssl.cnf Section auswaehlen
							CONF_SECTION=server_cert
							CONF_SECT=server_ca
						else
							CONF_SECTION=client_cert
							CONF_SECT=client_ca
						fi
						# Zertifikate konfigurieren, ... und erstellen.
						conf_ca -c
					else
						no_ca_msg $SUBDIR
					fi
				else
					no_subdir_msg
				fi
				## }}}
				main_ca_menu $Menu_Opt
				;;
			$lv_CA_Import)
				# CA importieren# {{{
				autoload -U ca_certs_import
				ca_certs_import
				## }}}
				main_ca_menu $lv_CA_Import
				;;
			$lv_CA_Export)
				# CA exportieren# {{{
				if [ -n "$SUBDIR" ] ; then
					CERT_EXPORT_TITLE="${SUBDIR}::${lv_CA}::${lv_CA_Export}"
					# Funktion (export_filename_format), bestimmt den Dateinamen# {{{
					# der ZielDatei.
					#
					# usage: export_filename_format FILE FORMAT
					# FORMAT - der, pem, pkcs#12, tar, txt, zip
					#
					export_filename_format() {
						if [[ ${#argv} == 2 ]] ; then
							unset -- FORMAT
							if [ -f ${KWSSL_DIR}/${SUBDIR}/${1} ] ; then
								if [[ $1 == cacert.pem ]] ; then
									ExportName="${1%.*}"
								else
									ExportName="${1%.cert.*}"
								fi
								case "$2" in
									der|pem|p12|tar|txt|zip)
										FORMAT="$2"
										;;
									*)
										;;
								esac
								if [ "$ExportName" = cacert ] ; then
									Export_FileName="${HOME}/${SUBDIR}-cert.${FORMAT}"
								else	
									Export_FileName="${HOME}/${MAIL}-cert.${FORMAT}"
								fi
							fi
						else
							no_para_msg $0
						fi
					}
					## }}}
					# Funktion (check_ca_filenames)# {{{
					check_ca_filenames() {
						unset -- CACERT CAKEY
						if [[ $SUBDIR == RootCA ]] ; then
							CAKEY="${KWSSL_DIR}/${SUBDIR}/private/cakey.pem"
							CACERT="${KWSSL_DIR}/${SUBDIR}/cacert.pem"
						else
							if [ "$ExportName" = cacert ] ; then
								CAKEY="${KWSSL_DIR}/${SUBDIR}/private/cakey.pem"
								CACERT="${KWSSL_DIR}/${SUBDIR}/cacert.pem"
							else
								CAKEY="${KWSSL_DIR}/${SUBDIR}/private/${ExportName}.key"
								CACERT="${KWSSL_DIR}/${SUBDIR}/${ExportName}.cert.pem"
							fi
						fi
					}
					## }}}
					# Funktion (export_filename), Export Dateinamen eingeben# {{{
					#
					# usage: export_filename [ der | pem | p12 | tar | txt | zip ]
					#
					export_filename() {
						unset -- SUFFIX
						local SUFFIX
						if [[ ${#argv} == 1 ]] ; then
							SUFFIX="$1"
						fi
						#
						EXPORT_FILENAME_MSG=$(gettext 'Geben Sie den Export Dateinamen mit SUFFIX $SUFFIX ein.')
						inputbox "$lv_ExportFilename" "$EXPORT_FILENAME_MSG" "$Export_FileName"
						if [ -n "$gv_Auswahl" ] ; then
							Export_FileName="$gv_Auswahl"
						else
							if [ "$ExportName" = cacert ] ; then
								Export_FileName="${HOME}/${SUBDIR}-cert.${SUFFIX}"
							else	
								Export_FileName="${HOME}/${MAIL}-cert.${SUFFIX}"
							fi
						fi
					}
					## }}}
					# Funktion (cert_choice_menu)# {{{
					cert_choice_menu() {
						CERT_EXPORT_MENU=($CERTS_VAL_M)
						radiolist "$CERT_EXPORT_TITLE" "$gv_Menupoint" "$CERT_EXPORT_MENU"
					}
					## }}}
					# Funktion (export_menu)# {{{
					export_menu() {
						if [[ $Export_File == cacert.pem ]] ; then
							EXPORT_MENU=(PEM \"\" on DER \"\" off TXT \"\" off)
						else
							EXPORT_MENU=(PEM \"\" on DER \"\" off PKCS#12 \"\" off
							TAR \"\" off TXT \"\" off ZIP \"\" off)
						fi
						#
						radiolist "$CERT_EXPORT_TITLE" "$gv_Menupoint" "$EXPORT_MENU"
					}
					## }}}
					search_ca -v $SUBDIR
					if [[ -n ${CERTS_VAL_M[1]} ]] ; then
						cert_choice_menu
						while [ "$gv_Auswahl" ] ; do
							case $gv_Auswahl in
								HELP*)
						    	    # Hilfe Messagebox
									script_help export_ca_help
									cert_choice_menu
									;;
								*)
									# Auswahl der Export Formate,
									# Daten der CA einlesen etc.
									Export_File="$gv_Auswahl"
									export_menu
									while [ "$gv_Auswahl" ] ; do
										case $gv_Auswahl in
											HELP*)
									    	    # Hilfe Messagebox
												script_help export_ca_help
												export_menu
												;;
											DER)
												# Zertifikat nach DER exportieren
												#
												# Funktion manage_export_most
												autoload -U manage_export_most
												manage_export_most "$Export_File" der
												break 2
												;;
											PEM)
												# Zertifikat nach PEM exportieren
												#
												# Funktion manage_export_pem
												autoload -U manage_export_pem
												manage_export_pem "$Export_File" pem
												break 2
												;;
											PKCS*)
												# Zertifikat nach PKCS#12 exportieren
												#
												# Funktion manage_export_pkcs12
												autoload -U manage_export_pkcs12
												manage_export_pkcs12 "$Export_File" p12
												break 2
												;;
											TAR)
												# Zertifikat nach TAR exportieren
												#
												# Funktion manage_export_most
												autoload -U manage_export_most
												manage_export_most "$Export_File" tar
												break 2
												;;
											TXT)
												# Zertifikat nach TXT exportieren
												#
												# Funktion manage_export_most
												autoload -U manage_export_most
												manage_export_most "$Export_File" txt
												break 2
												;;
											ZIP)
												# Zertifikat nach ZIP exportieren
												#
												# Funktion manage_export_most
												autoload -U manage_export_most
												manage_export_most "$Export_File" zip
												break 2
												;;
											*)
												break 2
												;;
										esac
									done
									;;
							esac
						done
					else
						no_cas_valid_msg
					fi
				else
					no_subdir_msg
				fi
				## }}}
				main_ca_menu $lv_CA_Export
				;;
			$lv_CA_Revoke)
				# Zertifikate einer CA für ungueltig erklaeren# {{{
				if [ -n "$SUBDIR" ] ; then
					GROUND=${GROUND:-unspecified}
					CERT_REVOKE_TITLE="${SUBDIR}::${lv_CA}::${lv_CA_Revoke}"
					# Funktion (cert_revoke_menu)# {{{
					cert_revoke_menu() {
						CERT_MENU=($CERTS_VAL_M)
						radiolist "$CERT_REVOKE_TITLE" "$gv_Menupoint" "$CERT_MENU"
					}
					## }}}
					# Funktion (ground_revoke_menu)# {{{
					#
					ground_revoke_menu() {
						GROUND_REVOKE_MENU=(unspecified \"\" on
						KeyCompromise \"\" off
						CaCompromise \"\" off
						AffiliationChanged \"\" off 
						Superseded \"\" off CessationOfOperation \"\" off
						CertificatHold \"\" off)
						radiolist "$CERT_REVOKE_TITLE" "$gv_Menupoint" "$GROUND_REVOKE_MENU"
					}
					## }}}
					# Funktion (conf_revoke_menu)# {{{
					#
					lv_Ground=$(gettext 'Grund')
					#
					conf_revoke_menu() {
						CONF_REVOKE_MENU=(\"$lv_Ssl_Password\" \"$CA_PASS\"
						$lv_Ground \"$GROUND\" $gv_Save \"\" $gv_Back \"\")
						menubox "$CERT_REVOKE_TITLE" "$gv_Menupoint" "$CONF_REVOKE_MENU"
					}
					## }}}
					search_ca -v $SUBDIR
					if [ -n "${CERTS_VAL_M[1]}" ] ; then
						cert_revoke_menu
						while [ "$gv_Auswahl" ] ; do
							case $gv_Auswahl in
								HELP*)
						    	    # Hilfe Messagebox
									script_help ca_revoke_help
									cert_revoke_menu
									;;
								*)
									# Revoke Menue
									REVOKE_FILE="$gv_Auswahl"
									conf_revoke_menu
									while [ "$gv_Auswahl" ] ; do
										case $gv_Auswahl in
											HELP*)
									    	    # Hilfe Messagebox
												script_help ca_revoke_help
												conf_revoke_menu
												;;
											"$lv_Ssl_Password")
												# Passwort fuer das Zertifikat eingeben# {{{
												CERT_REVOKE_MSG=$(gettext 'Geben Sie bitte das Password fuer dieses Zertifikat ein.')
												password "$CERT_REVOKE_TITLE" "$CERT_REVOKE_MSG"
												if [ -n "$PASSPHRASE" ] ; then
													password_display "$PASSPHRASE"
													if [ -n "$gv_Star_Passphrase" ] ; then
														CA_PASS="$gv_Star_Passphrase"
													else
														unset -- CA_PASS PASSPHRASE
													fi
												else
													unset -- CA_PASS PASSPHRASE
												fi
												## }}}
												conf_revoke_menu $lv_Ssl_Password
												;;
											$lv_Ground)
												# Grund angeben/auswaehlen# {{{
												ground_revoke_menu
												while [ -n "$gv_Auswahl" ] ; do
													case $gv_Auswahl in
														HELP*)
												    	    # Hilfe Messagebox
															script_help ca_revoke_help
															ground_revoke_menu
															;;
														*)
															# Auswahl uebernehmen
															GROUND="$gv_Auswahl"
															break
															;;
													esac
												done
												## }}}
												conf_revoke_menu $lv_Ground
												;;
											$gv_Save)
												# CAs und Zertifikate widerrufen# {{{
												cd ${KWSSL_DIR}/${SUBDIR}
												# Ist REVOKE_FILE gleich einer SubCA
												# (cacert.pem) muessen die Schluessel von
												# RootCA genommen werden.
												if [[ $REVOKE_FILE == cacert.pem ]] ; then
													if [ -n "$PASSPHRASE" ] ; then
														openssl ca -config ${KWSSL_DIR}/RootCA/${KWSSL2RC_NAME} \
															-batch -name ca_ca \
															-revoke $REVOKE_FILE \
															-passin pass:${PASSPHRASE} || prog_failure
														openssl ca -config ${KWSSL_DIR}/RootCA/${KWSSL2RC_NAME} \
															-batch -name ca_ca \
															-gencrl -out crl/crl.pem \
															-passin pass:${PASSPHRASE} || prog_failure
														#
														unset -- PASSPHRASE CA_PASS
													else
														MSG=$(gettext 'Sie muessen ein Passwort eingeben.')
														msgbox "$gv_Info" "$MSG"
													fi

												else
													openssl ca -config $KWSSL2RC \
														-batch \
														-revoke $REVOKE_FILE \
														-passin pass:${PASSPHRASE} || prog_failure
														#-batch -name $CONF_SECT \
													openssl ca -config $KWSSL2RC \
														-batch \
														-gencrl -out crl/crl.pem \
														-passin pass:${PASSPHRASE} || prog_failure
													#
													unset -- PASSPHRASE CA_PASS
												fi
												## }}}
												break
												;;
											$gv_Back)
												break
												;;
										esac
									done
									#
									break
									;;
							esac
						done
					else
						no_cas_valid_msg
					fi
				else
					no_subdir_msg
				fi
				## }}}
				main_ca_menu $lv_CA_Revoke
				;;
			$lv_Dh_File)
				# Diffie Hellman Parameter Datei erzeugen# {{{
				########################################
				# TODO:
				# Datei erzeugen oder in Zertifikat
				# hinzufuegen?
				########################################
				# Funktion (main_ca_menu)# {{{
				#
				KEYLENGTH="1024"
				#
				dh_menu() {
					DH_FILENAME="${DH_FILENAME:-${HOME}/dh${KEYLENGTH}.pem}"
					#
					DH_TITLE="$lv_Dh_File"
		    		DH_MENU=($lv_Filename \"$DH_FILENAME\"
					$lv_Ssl_Key_length \"$KEYLENGTH\"
					$gv_Create \"\"
					$gv_Back \"\")
					#
					if [[ ${#argv} == 1 ]] ; then
						menubox -d "$1" "$DH_TITLE" "$gv_Menupoint" "$DH_MENU"
					else
						menubox "$DH_TITLE" "$gv_Menupoint" "$DH_MENU"
					fi
				}
				# }}}
				dh_menu
				while [ -n "$gv_Auswahl" ] ; do
					case "$gv_Auswahl" in
						HELP*)
							script_help dh_help
							dh_menu
							;;
						$lv_Filename)
							# Dateiname eingeben# {{{
							DH_FILENAME_MSG=$(gettext 'Geben Sie den Dateinamen ein.')
							inputbox "$lv_Filename" "$DH_FILENAME_MSG" "$DH_FILENAME"
							if [ -n "$gv_Auswahl" ] ; then
								DH_FILENAME="$gv_Auswahl"
							else
								DH_FILENAME="${HOME}/dh${KEYLENGTH}.pem"
							fi
							## }}}
							dh_menu $lv_Filename
							;;
						$lv_Ssl_Key_length)
							# Schluessellaenge (numbits) auswaehlen# {{{
							#
							# HELPFILE belegen fuer keylength_input.
							HELPFILE="dh_help"
							keylength_input
							## }}}
							dh_menu $lv_Ssl_Key_length
							;;
						$gv_Create)
							# Diffie Hellman Datei erstellen.# {{{
							if [ -n "$DH_FILENAME" -a -f "$DH_FILENAME" ] ; then
								MSG=$(gettext 'Die Datei "$DH_FILENAME" ist schon vorhanden.\n\nSoll sie ueberschrieben werden ($gv_Yes/$gv_No)?')
								yesno "$gv_Info" "$MSG"
								if [ "$?" = 0 ] ; then
									openssl dhparam -out "$DH_FILENAME" $KEYLENGTH || prog_failure
								fi
								break
							elif [ -n "$DH_FILENAME" -a ! -f "$DH_FILENAME" ] ; then
								openssl dhparam -out "$DH_FILENAME" $KEYLENGTH || prog_failure
								break
							else
								MSG=$(gettext 'Sie muessen mindestens den Menupunkt $lv_Filename mit einem Wert belegen.')
								msgbox "$gv_Info" "$MSG"
								dh_menu $lv_Filename
							fi
							## }}}
							;;
						$gv_Back)	break
							;;
					esac
				done
				## }}}
				main_ca_menu $lv_Dh_File
				;;
			$gv_Delete)
				# CAs loeschen# {{{
				if [ -n "$SUBDIR" ] ; then
					unset -- $UNSET
					# Funktion (del_cert_choice_menu)# {{{
					CERT_TITLE="${SUBDIR}::${lv_CA}::${gv_Delete}"
					del_cert_choice_menu() {
						DEL_CERT_MENU=($CERTS_NON_VAL_M)
						checklist "$CERT_TITLE" "$gv_Menupoint" "$DEL_CERT_MENU"
					}
					## }}}
					# nach $KWSSL_DIR wechseln
					if [[ $SUBDIR == RootCA ]] ; then
						# komplette kwssl2 PKI Struktur loeschen
						rm -rfv ${KWSSL_DIR}/* >&/dev/null
					else
						search_ca -u $SUBDIR
						if [ -n "${CERTS_NON_VAL_M[1]}" ] ; then
							del_cert_choice_menu
							while [ "$gv_Auswahl" ] ; do
								case "$gv_Auswahl" in
									HELP*)
							    	    # Hilfe Messagebox
										script_help main_ca_help
										del_cert_choice_menu
										;;
									*)
										# Auswahl uebernehmen# {{{
										cd $KWSSL_DIR
										for i in ${=gv_Auswahl} ; {
											local File
											File="${i%%.*}"
											if [[ $File == cacert ]] ; then
												rm -rfv ./${SUBDIR} >&/dev/null
											else
												rm -rfv ./${SUBDIR}/${File}.* \
												./${SUBDIR}/req/${File}.* \
												./${SUBDIR}/crt/${File}.* \
												./${SUBDIR}/${File}.* \
												./${SUBDIR}/private/${File}.* >&/dev/null
											fi
										}
										## }}}
										unset -- File
										break
										;;
								esac
							done
						else
							no_cas_nonvalid_msg
						fi
					fi
				else
					no_subdir_msg
				fi
				## }}}
				main_ca_menu $gv_Delete
				;;
			$gv_Back)
				# abbrechen
				break
				;;
		esac
	done	
}
## }}}
