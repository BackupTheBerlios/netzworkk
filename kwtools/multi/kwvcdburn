#!/bin/zsh
#
# Autor: Kai Wilke <kiste@netzworkk.de> 07.01.2012
#
# Script: kwvcdburn, kreiert und brennt (S)VCD Filme
# Version: 0.0.8
#

trap 'setterm -inversescreen off ; setterm -reset ;
rm -rf $gv_WorkDir &>/dev/null' EXIT INT

gv_ScriptName=${0##*/}

#
# Verzeichniss in denen nach Funktionen gesucht wird
#
if [ -f /usr/local/share/kwtools/functions/sys/script_init ] ; then
	PREFIX=/usr/local
else
	PREFIX=/usr
fi
Script_init_Fpath="${PREFIX}/share/kwtools/functions/sys"
export TEXTDOMAINDIR="${PREFIX}/share/locale"
export TEXTDOMAIN="$gv_ScriptName"

if [ -z ${(M)${FPATH}##*${Script_init_Fpath}*} ] ; then
	FPATH=${Script_init_Fpath}:${FPATH}
fi

autoload -U script_init

# Scriptinitialisierung
script_init

# auf Programme pruefen
prog_check vcdimager vcdxgen vcdxbuild jpeg2yuv mplex yuvscaler 
if [ -n "${NO_PROGS[1]}" ] ; then
	exit 0
fi

# Soll die alte Konfiguration uebernommen werden (ja/nein)?
if [ -f "${gv_HomePath}/.kwtools/vcdburnrc" -a ! -f "${gv_HomePath}/.kwtools/kwvcdburnrc" ] ; then
	CONVERT_TITLE=$(gettext 'Konfigurationsuebernahme')
	CONVERT_MSG=$(gettext 'Soll die Konfigurations Datei ${gv_HomePath}/.kwtools/vcdburnrc nach ${gv_HomePath}/.kwtools/kwvcdburnrc uebernommen werden (ja/nein)? Bei nein wird die alte Konfigurationsdatei nur geloescht.')
	yesno "$CONVERT_TITLE" "$CONVERT_MSG"
	if [ "$?" = 0 ] ; then
		mv "${gv_HomePath}/.kwtools/vcdburnrc" "${gv_HomePath}/.kwtools/kwvcdburnrc" &>/dev/null
	else
		rm "${gv_HomePath}/.kwtools/vcdburnrc" &>/dev/null
	fi
fi

# Konfigurationen einlesen
read_file kwvcdburnrc

# Variablen
if [ -z "$FILM_DIR" ] ; then
	FILM_DIR="$HOME"
fi	
if [ -z "$VCD_TYPE" ] ; then
	VCD_TYPE="svcd"
fi
if [ -z "$FRAME_RATE" ] ; then
	FRAME_RATE=25
fi
if [ -z "$FRAME_SIZE" ] ; then
	FRAME_SIZE="480x576"
fi
if [ -z "$IMAGE_FORMAT" ] ; then
	IMAGE_FORMAT="2"
fi
if [ -z "$SIZE" ] ; then
	SIZE="200"
fi

CREATE_NAME_MSG=$(gettext 'Vergeben Sie einen Namen fuer die Video-CD ohne .cue Endung, ansonsten heisst sie videocd.cue.')
NAME_MSG=$(gettext 'Vergeben Sie einen Namen fuer die Photo-CD ohne .cue Endung, ansonsten wird die Datei photocd.cue genannt.')

# Funktion haupt_menue{{{
lv_Video_Cd=$(gettext 'Video-CD')
lv_Photo_Cd=$(gettext 'Photo-CD')
lv_Burn=$(gettext 'brennen')
MAIN_MENU=($gv_Configuration \"\" $lv_Video_Cd \"\" $lv_Photo_Cd \"\" $lv_Burn \"\" $gv_Back \"\")
#
haupt_menue() {
	menubox "$gv_Mainmenu" "$gv_Menupoint" "$MAIN_MENU"
}
#}}}

##############################################################
#
# Hauptprogramm
#
##############################################################
#
hw_conf
cdrom
haupt_menue
while [ "$gv_Auswahl" ] ; do
	case $gv_Auswahl in
		HELP*)
    	    # Hilfe Messagebox
			script_help help
			haupt_menue
			;;
		$gv_Configuration)
			# Konfiguration der ~/.kwtools/kwvcdburnrc
			autoload -U kwvcdburn_conf kwvcdburn_config
			kwvcdburn_conf
			haupt_menue
			;;
		$lv_Video_Cd)
			# VCD Image erstellen{{{
			#
			# Entweder mehrere Filme zusammenpacken film1 film2 ...
			# oder einzeln. Groesse zusammenrechnen.
			PROG=vcdimager
			FORMAT="MPEG sequence"
			SUFFIX=".mpg .mpeg .MPG .MPEG"
			# Werte auch in $gv_LogFile$$ schreiben
			U_OPT=no
			file_choice "$FILM_DIR" multi
			#
			if [ "${WERT[1]}" ] ; then
				VIDEO_TITLE=($lv_Video_Cd)
				#
				# Programm vcdimager ausfuehren.
				#
				typeset -L V_Anz
				V_Anz=`wc -l <$gv_LogFile$$`
				#
				# Soll eine VCD Struktur fuer alle Dateien erstellt werden,
				# wenn es mehr als eine Datei gibt (ja/nein)?
				if [ "$V_Anz" -gt 1 ] ; then
					CREATE_MULTI_QUESTION_MSG=$(gettext 'Soll aus allen Dateien eine einheitliche Video-CD Struktur erzeugt werden (Ja/nein)?')
					yesno "$VIDEO_TITLE" "$CREATE_MULTI_QUESTION_MSG"
					if [ "$?" = 0 ] ; then
						# Dateinamen vergeben
						inputbox "$VIDEO_TITLE" "$CREATE_NAME_MSG"
						if [ -n "$gv_Auswahl" ] ; then
							FILE_NAME="$gv_Auswahl"
							CREATE_MULTI_MSG=$(gettext 'Erzeuge Video-CD ${FILE_NAME}.cue aus de(r/n) Dateie(n) ${FILE_NAME}.')
							# zusammenfuegen
							$PROG -t $VCD_TYPE -c ${FILE_NAME%.*}.cue -b ${FILE_NAME%.*}.bin $WERT | \
							progressbox "$VIDEO_TITLE" "$CREATE_MSG" || prog_failure
						else
							no_input_msg
						fi
					else
						# alle Dateien einzeln umwandeln.
						Anz=1
						CREATE_MSG=$(gettext 'Erzeuge Video-CD: ${file% }.')
						while read file ; do
							$PROG -t $VCD_TYPE -c ${file%.*}.cue -b ${file%.*}.bin --volume-count=$V_Anz --volume-number=$Anz ${file% } | \
								progressbox "$VIDEO_TITLE" "$CREATE_MSG" || prog_failure
							(( Anz++ ))
						done <$gv_LogFile$$
					fi
				else
					# einzelne Datei umwandeln
					$PROG -t $VCD_TYPE -c ${WERT%.*}.cue -b ${WERT%.*}.bin ${WERT% } | \
					progressbox "$VIDEO_TITLE" "$CREATE_MSG" || prog_failure
				fi
				rm -rf $gv_LogFile$$ &>/dev/null
			fi
			#}}}
			haupt_menue
			;;
		$lv_Photo_Cd)
			####################
			# TODO:
			# testen auch andere VCD Formate
			####################
			# Photo-CD erstellen# {{{
			#
			# Funktion multiplex_image, wandelt Bilder in# {{{
			# die richtige Groesse um und multiplext diese.
			#
			# usage: multiplex_image DATEIEN
			#
			multiplex_image() {
				if [ "$#" -ge 1 ] ; then
					local Anz File
					integer Anz
					unset -- File VALUE
					File="$1"
					case "$VCD_TYPE" in
						svcd)
							VCD_SUFFIX=m2v
							;;
						*)
							VCD_SUFFIX=m1v
							;;
					esac
					# einzelne JPEG Dateien umwandeln.
					Anz=0
					for a in ${=File} ; {
						if [ -n "`print ${(M)${(f)"$(file -b "$a")"}##*(image data)*}`" ] ; then
							# erst pruefen ob die Bildhoehe ein vielfaches von 16 ist.
							# Wenn nicht abbrechen.
							if jpeg2yuv -f $FRAME_RATE -j $a &>/dev/null ; then
								jpeg2yuv -f $FRAME_RATE -j $a -I p -n -1 | \
								yuvscaler -O $FRAME_SIZE | \
								mpeg2enc -a $IMAGE_FORMAT -T $SIZE -n p \
								-f 7 -o ${a%.*}.${VCD_SUFFIX}
								# mplexen der Dateien zur mpg Datei
								mplex -f 7 -o ${a%.*}.mpg ${a%.*}.${VCD_SUFFIX} || prog_failure
								(( Anz++ ))
								VALUE[Anz]="${a%.*}.mpg"
							else
								MSG=$(gettext 'Die Bildhoehe ist kein mehrfaches von 16. Sie muessen das Bild neu skalieren.')
								msgbox "$gv_Info" "$MSG"
								break 2
							fi
						fi
					}
					#
					# Programm vcdxgen ausfuehren.
					vcdxgen $VALUE -t $VCD_TYPE -o ${gv_WorkDir}/photocd.xml
					# Namen fuer die Video-CD vergeben
					inputbox "$PHOTO_TITLE" "$NAME_MSG"
					if [ -n "$gv_Auswahl" ] ; then
						VideoCd="$gv_Auswahl"
					else
						VideoCd=photocd
					fi
					# Programm vcdxbuild ausfuehren.
					vcdxbuild -c ${VideoCd}.cue -b ${VideoCd}.bin ${gv_WorkDir}/photocd.xml
				else
					no_para_msg $0
				fi
			}
			## }}}
			# Funktion photo_choice_menu, komplettes Verzeichnis oder einzeln# {{{
			#
			lv_Choice=$(gettext 'Auswahl')
			lv_Complete=$(gettext 'komplett')
			PHOTO_TITLE=($lv_Photo_Cd)
			PHOTO_CHOICE_MENU=($lv_Choice \"\" $lv_Complete \"\" $gv_Back \"\")
			photo_choice_menu() {
				menubox "$PHOTO_TITLE" "$gv_Menupoint" "$PHOTO_CHOICE_MENU"
			}
			## }}}
			photo_choice_menu
			while [ -n "$gv_Auswahl" ] ; do
				case "$gv_Auswahl" in
					HELP*)	script_help photo_choice_help
						photo_choice_menu
						;;
					$lv_Choice)
						FORMAT="IMAGE"
						file_choice "$PHOTO_DIR" multi
						# Einzelne Dateien umwandeln
						if [ "${WERT[1]}" ] ; then
							multiplex_image "$WERT"
						fi
						photo_choice_menu
						;;
					$lv_Complete)
						# komplette Verzeichnisse umwandeln.
						dselect "$PHOTO_DIR"
						if [ -n "$VERZ" ] ; then
							dselect_check "$VERZ"
							if [ -n "$VERZ" ] ; then
								cd "$VERZ"
								multiplex_image "`print *(.)`"
							fi
						fi
						photo_choice_menu
						;;
					$gv_Back)	break
						;;
				esac
			done
			## }}}
			haupt_menue
			;;
		$lv_Burn)
			# Film brennen
			multi_conf
			cd_dvd_burn --vcd
			haupt_menue
			;;
		$gv_Exit)	break
			;;
	esac
done	
#
# umounten des Mount-Verzeichnis
if [ "$MOUNT_PATH" ] ; then
	mount_check -u $MOUNT_PATH
fi
unset -- FILM_DIR gv_Auswahl MOUNT MOUNTDIR FORMAT VCD_TYPE CDROM VOLUME_SET VOLUME_COUNT V_Anz
exit 0
### Modeline {{{
### vim:ft=zsh:foldmethod=marker
### vim:set ts=4:                                                                               
### }}}
